<!DOCTYPE html>



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    Automap
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
        <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../../index.html" />
        <link rel="up" title="ORM Extensions" href="index.html" />
        <link rel="next" title="Baked Queries" href="baked.html" />
        <link rel="prev" title="Association Proxy" href="associationproxy.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.31</span>


        | Release Date: June 18, 2024

    </div>

    <h1><a href="../../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="../quickstart.html">ORM Quick Start</a></span></li>
<li><span class="link-container"><a class="reference external" href="../mapper_config.html">ORM Mapped Class Configuration</a></span></li>
<li><span class="link-container"><a class="reference external" href="../relationships.html">Relationship Configuration</a></span></li>
<li><span class="link-container"><a class="reference external" href="../queryguide/index.html">ORM Querying Guide</a></span></li>
<li><span class="link-container"><a class="reference external" href="../session.html">Using the Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="../extending.html">Events and Internals</a></span></li>
<li><span class="link-container"><a class="reference external" href="index.html">ORM Extensions</a></span><ul>
<li><span class="link-container"><a class="reference external" href="asyncio.html">Asynchronous I/O (asyncio)</a></span></li>
<li><span class="link-container"><a class="reference external" href="associationproxy.html">Association Proxy</a></span></li>
<li class="selected"><span class="link-container"><strong>Automap</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#basic-use">Basic Use</a></span></li>
<li><span class="link-container"><a class="reference external" href="#generating-mappings-from-an-existing-metadata">Generating Mappings from an Existing MetaData</a></span></li>
<li><span class="link-container"><a class="reference external" href="#generating-mappings-from-multiple-schemas">Generating Mappings from Multiple Schemas</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#automapping-same-named-tables-across-multiple-schemas">Automapping same-named tables across multiple schemas</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#specifying-classes-explicitly">Specifying Classes Explicitly</a></span></li>
<li><span class="link-container"><a class="reference external" href="#overriding-naming-schemes">Overriding Naming Schemes</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationship-detection">Relationship Detection</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#custom-relationship-arguments">Custom Relationship Arguments</a></span></li>
<li><span class="link-container"><a class="reference external" href="#many-to-many-relationships">Many-to-Many relationships</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationships-with-inheritance">Relationships with Inheritance</a></span></li>
<li><span class="link-container"><a class="reference external" href="#handling-simple-naming-conflicts">Handling Simple Naming Conflicts</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#using-automap-with-explicit-declarations">Using Automap with Explicit Declarations</a></span></li>
<li><span class="link-container"><a class="reference external" href="#intercepting-column-definitions">Intercepting Column Definitions</a></span></li>
<li><span class="link-container"><a class="reference external" href="#api-reference">API Reference</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.automap_base"><code class="docutils literal notranslate"><span class="pre">automap_base()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">AutomapBase</span></code></a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.AutomapBase.by_module"><code class="docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.AutomapBase.classes"><code class="docutils literal notranslate"><span class="pre">AutomapBase.classes</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.AutomapBase.metadata"><code class="docutils literal notranslate"><span class="pre">AutomapBase.metadata</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.AutomapBase.prepare"><code class="docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.classname_for_table"><code class="docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.name_for_collection_relationship"><code class="docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.ext.automap.generate_relationship"><code class="docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="baked.html">Baked Queries</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative/index.html">Declarative Extensions</a></span></li>
<li><span class="link-container"><a class="reference external" href="mypy.html">Mypy  / Pep-484 Support for ORM Mappings</a></span></li>
<li><span class="link-container"><a class="reference external" href="mutable.html">Mutation Tracking</a></span></li>
<li><span class="link-container"><a class="reference external" href="orderinglist.html">Ordering List</a></span></li>
<li><span class="link-container"><a class="reference external" href="horizontal_shard.html">Horizontal Sharding</a></span></li>
<li><span class="link-container"><a class="reference external" href="hybrid.html">Hybrid Attributes</a></span></li>
<li><span class="link-container"><a class="reference external" href="indexable.html">Indexable</a></span></li>
<li><span class="link-container"><a class="reference external" href="instrumentation.html">Alternate Class Instrumentation</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="../examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="associationproxy.html" title="previous chapter">Association Proxy</a></li>
                <li><b>Next:</b>
                <a href="baked.html" title="next chapter">Baked Queries</a></li>

            <li><b>Up:</b> <a href="../../index.html">Home</a></li>
                    <ul><li><a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="index.html" title="ORM Extensions">ORM Extensions</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#module-sqlalchemy.ext.automap">Automap</a><ul>
<li><a class="reference internal" href="#basic-use">Basic Use</a></li>
<li><a class="reference internal" href="#generating-mappings-from-an-existing-metadata">Generating Mappings from an Existing MetaData</a></li>
<li><a class="reference internal" href="#generating-mappings-from-multiple-schemas">Generating Mappings from Multiple Schemas</a><ul>
<li><a class="reference internal" href="#automapping-same-named-tables-across-multiple-schemas">Automapping same-named tables across multiple schemas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specifying-classes-explicitly">Specifying Classes Explicitly</a></li>
<li><a class="reference internal" href="#overriding-naming-schemes">Overriding Naming Schemes</a></li>
<li><a class="reference internal" href="#relationship-detection">Relationship Detection</a><ul>
<li><a class="reference internal" href="#custom-relationship-arguments">Custom Relationship Arguments</a></li>
<li><a class="reference internal" href="#many-to-many-relationships">Many-to-Many relationships</a></li>
<li><a class="reference internal" href="#relationships-with-inheritance">Relationships with Inheritance</a></li>
<li><a class="reference internal" href="#handling-simple-naming-conflicts">Handling Simple Naming Conflicts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-automap-with-explicit-declarations">Using Automap with Explicit Declarations</a></li>
<li><a class="reference internal" href="#intercepting-column-definitions">Intercepting Column Definitions</a></li>
<li><a class="reference internal" href="#api-reference">API Reference</a><ul>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.automap_base"><code class="docutils literal notranslate"><span class="pre">automap_base()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">AutomapBase</span></code></a><ul>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module"><code class="docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.classes"><code class="docutils literal notranslate"><span class="pre">AutomapBase.classes</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.metadata"><code class="docutils literal notranslate"><span class="pre">AutomapBase.metadata</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare"><code class="docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table"><code class="docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship"><code class="docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship"><code class="docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-extensions-automap" >
        
<section id="module-sqlalchemy.ext.automap">
<span id="automap"></span><span id="automap-toplevel"></span><h1>Automap<a class="headerlink" href="#module-sqlalchemy.ext.automap" title="Link to this heading">¶</a></h1>
<p>Define an extension to the <a class="reference internal" href="declarative/api.html#module-sqlalchemy.ext.declarative" title="sqlalchemy.ext.declarative"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.declarative</span></code></a> system
which automatically generates mapped classes and relationships from a database
schema, typically though not necessarily one which is reflected.</p>
<p>It is hoped that the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> system provides a quick
and modernized solution to the problem that the very famous
<a class="reference external" href="https://sqlsoup.readthedocs.io/en/latest/">SQLSoup</a>
also tries to solve, that of generating a quick and rudimentary object
model from an existing database on the fly.  By addressing the issue strictly
at the mapper configuration level, and integrating fully with existing
Declarative class techniques, <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> seeks to provide
a well-integrated approach to the issue of expediently auto-generating ad-hoc
mappings.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The <a class="reference internal" href="#"><span class="std std-ref">Automap</span></a> extension is geared towards a
“zero declaration” approach, where a complete ORM model including classes
and pre-named relationships can be generated on the fly from a database
schema. For applications that still want to use explicit class declarations
including explicit relationship definitions in conjunction with reflection
of tables, the <a class="reference internal" href="declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection" title="sqlalchemy.ext.declarative.DeferredReflection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeferredReflection</span></code></a> class, described at
<a class="reference internal" href="../declarative_tables.html#orm-declarative-reflected-deferred-reflection"><span class="std std-ref">Using DeferredReflection</span></a>, is a better choice.</p>
</div>
<section id="basic-use">
<span id="automap-basic-use"></span><h2>Basic Use<a class="headerlink" href="#basic-use" title="Link to this heading">¶</a></h2>
<p>The simplest usage is to reflect an existing database into a new model.
We create a new <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class in a similar manner as to how
we create a declarative base class, using <a class="reference internal" href="#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a>.
We then call <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> on the resulting base class,
asking it to reflect the schema and produce mappings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="c1"># engine, suppose it has two tables &#39;user&#39; and &#39;address&#39; set up</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="c1"># reflect the tables</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># mapped classes are now created with names by default</span>
<span class="c1"># matching that of the table name.</span>
<span class="n">User</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># rudimentary relationships are produced</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;foo@bar.com&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)))</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="c1"># collection-based relationships are by default named</span>
<span class="c1"># &quot;&lt;classname&gt;_collection&quot;</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">print</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">address_collection</span><span class="p">)</span></pre></div>
</div>
<p>Above, calling <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> while passing along the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflect</span></code></a> parameter indicates that the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>
method will be called on this declarative base
classes’ <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection; then, each <strong>viable</strong>
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> within the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
will get a new mapped class
generated automatically.  The <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
objects which
link the various tables together will be used to produce new, bidirectional
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects between classes.
The classes and relationships
follow along a default naming scheme that we can customize.  At this point,
our basic mapping consisting of related <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> classes is
ready to use in the traditional way.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By <strong>viable</strong>, we mean that for a table to be mapped, it must
specify a primary key.  Additionally, if the table is detected as being
a pure association table between two other tables, it will not be directly
mapped and will instead be configured as a many-to-many table between
the mappings for the two referring tables.</p>
</div>
</section>
<section id="generating-mappings-from-an-existing-metadata">
<h2>Generating Mappings from an Existing MetaData<a class="headerlink" href="#generating-mappings-from-an-existing-metadata" title="Link to this heading">¶</a></h2>
<p>We can pass a pre-declared <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object to
<a class="reference internal" href="#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a>.
This object can be constructed in any way, including programmatically, from
a serialized file, or from itself being reflected using
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>.
Below we illustrate a combination of reflection and
explicit table declaration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">automap_base</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="c1"># produce our own MetaData object</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="c1"># we can reflect it ourselves from a database, using options</span>
<span class="c1"># such as &#39;only&#39; to limit what tables we look at...</span>
<span class="n">metadata</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;address&quot;</span><span class="p">])</span>

<span class="c1"># ... or just define our own Table objects with it (or combine both)</span>
<span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;user_order&quot;</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user.id&quot;</span><span class="p">)),</span>
<span class="p">)</span>

<span class="c1"># we can then produce a set of mappings from this MetaData.</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

<span class="c1"># calling prepare() just sets up mapped classes and relationships.</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c1"># mapped classes are ready</span>
<span class="n">User</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>
<span class="n">Order</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user_order</span></pre></div>
</div>
</section>
<section id="generating-mappings-from-multiple-schemas">
<span id="automap-by-module"></span><h2>Generating Mappings from Multiple Schemas<a class="headerlink" href="#generating-mappings-from-multiple-schemas" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method when used with reflection may reflect
tables from one schema at a time at most, using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.schema</span></code></a> parameter to indicate the name of a
schema to be reflected from. In order to populate the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a>
with tables from multiple schemas, <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> may be invoked
multiple times, each time passing a different name to the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.schema</span></code></a> parameter. The
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method keeps an internal list of
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects that have already been mapped, and will add new
mappings only for those <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects that are new since the
last time <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> was run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql://scott:tiger@localhost/test&quot;</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;test_schema&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;test_schema_2&quot;</span><span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method may be called
any number of times; only newly added tables will be mapped
on each run.   Previously in version 1.4 and earlier, multiple calls would
cause errors as it would attempt to re-map an already mapped class.
The previous workaround approach of invoking
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a> directly remains available as well.</p>
</div>
<section id="automapping-same-named-tables-across-multiple-schemas">
<h3>Automapping same-named tables across multiple schemas<a class="headerlink" href="#automapping-same-named-tables-across-multiple-schemas" title="Link to this heading">¶</a></h3>
<p>For the common case where multiple schemas may have same-named tables and
therefore would generate same-named classes, conflicts can be resolved either
through use of the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.classname_for_table</span></code></a> hook to
apply different classnames on a per-schema basis, or by using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.modulename_for_table</span></code></a> hook, which allows
disambiguation of same-named classes by changing their effective <code class="docutils literal notranslate"><span class="pre">__module__</span></code>
attribute. In the example below, this hook is used to create a <code class="docutils literal notranslate"><span class="pre">__module__</span></code>
attribute for all classes that is of the form <code class="docutils literal notranslate"><span class="pre">mymodule.&lt;schemaname&gt;</span></code>, where
the schema name <code class="docutils literal notranslate"><span class="pre">default</span></code> is used if no schema is present:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql://scott:tiger@localhost/test&quot;</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">module_name_for_table</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;mymodule.</span><span class="si">{</span><span class="n">table</span><span class="o">.</span><span class="n">schema</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;mymodule.default&quot;</span>


<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">modulename_for_table</span><span class="o">=</span><span class="n">module_name_for_table</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;test_schema&quot;</span><span class="p">,</span> <span class="n">modulename_for_table</span><span class="o">=</span><span class="n">module_name_for_table</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;test_schema_2&quot;</span><span class="p">,</span> <span class="n">modulename_for_table</span><span class="o">=</span><span class="n">module_name_for_table</span><span class="p">)</span></pre></div>
</div>
<p>The same named-classes are organized into a hierarchical collection available
at <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="sqlalchemy.ext.automap.AutomapBase.by_module"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a>.  This collection is traversed using the
dot-separated name of a particular package/module down into the desired
class name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.modulename_for_table</span></code></a>
hook to return a new <code class="docutils literal notranslate"><span class="pre">__module__</span></code> that is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the class is
<strong>not</strong> placed into the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="sqlalchemy.ext.automap.AutomapBase.classes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.classes</span></code></a> collection; only
classes that were not given an explicit modulename are placed here, as the
collection cannot represent same-named classes individually.</p>
</div>
<p>In the example above, if the database contained a table named <code class="docutils literal notranslate"><span class="pre">accounts</span></code> in
all three of the default schema, the <code class="docutils literal notranslate"><span class="pre">test_schema</span></code> schema, and the
<code class="docutils literal notranslate"><span class="pre">test_schema_2</span></code> schema, three separate classes will be available as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span><span class="o">.</span><span class="n">by_module</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">accounts</span>
<span class="n">Base</span><span class="o">.</span><span class="n">by_module</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">test_schema</span><span class="o">.</span><span class="n">accounts</span>
<span class="n">Base</span><span class="o">.</span><span class="n">by_module</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">test_schema_2</span><span class="o">.</span><span class="n">accounts</span></pre></div>
</div>
<p>The default module namespace generated for all <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> classes is
<code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code>. If no
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.modulename_for_table</span></code></a> hook is used, the
contents of <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="sqlalchemy.ext.automap.AutomapBase.by_module"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a> will be entirely within the
<code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code> namespace (e.g.
<code class="docutils literal notranslate"><span class="pre">MyBase.by_module.sqlalchemy.ext.automap.&lt;classname&gt;</span></code>), which would contain
the same series of classes as what would be seen in
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="sqlalchemy.ext.automap.AutomapBase.classes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.classes</span></code></a>. Therefore it’s generally only necessary to use
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="sqlalchemy.ext.automap.AutomapBase.by_module"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a> when explicit <code class="docutils literal notranslate"><span class="pre">__module__</span></code> conventions are
present.</p>
</section>
</section>
<section id="specifying-classes-explicitly">
<h2>Specifying Classes Explicitly<a class="headerlink" href="#specifying-classes-explicitly" title="Link to this heading">¶</a></h2>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If explicit classes are expected to be prominent in an application,
consider using <a class="reference internal" href="declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection" title="sqlalchemy.ext.declarative.DeferredReflection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeferredReflection</span></code></a> instead.</p>
</div>
<p>The <a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">automap</span></code></a> extension allows classes to be defined
explicitly, in a way similar to that of the <a class="reference internal" href="declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection" title="sqlalchemy.ext.declarative.DeferredReflection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeferredReflection</span></code></a> class.
Classes that extend from <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> act like regular declarative
classes, but are not immediately mapped after their construction, and are
instead mapped when we call <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a>.  The
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method will make use of the classes we’ve
established based on the table name we use.  If our schema contains tables
<code class="docutils literal notranslate"><span class="pre">user</span></code> and <code class="docutils literal notranslate"><span class="pre">address</span></code>, we can define one or both of the classes to be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="c1"># automap base</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>


<span class="c1"># pre-declare User for the &#39;user&#39; table</span>
<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="c1"># override schema elements like Columns</span>
    <span class="n">user_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>

    <span class="c1"># override relationships too, if desired.</span>
    <span class="c1"># we must use the same name that automap would use for the</span>
    <span class="c1"># relationship, and also must refer to the class name that automap will</span>
    <span class="c1"># generate for &quot;address&quot;</span>
    <span class="n">address_collection</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="n">collection_class</span><span class="o">=</span><span class="n">set</span><span class="p">)</span>


<span class="c1"># reflect</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># we still have Address generated from the tablename &quot;address&quot;,</span>
<span class="c1"># but User is the same as Base.classes.User now</span>

<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">print</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">address_collection</span><span class="p">)</span>

<span class="c1"># the backref is still there:</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">user</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>Above, one of the more intricate details is that we illustrated overriding
one of the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects that automap would have created.
To do this, we needed to make sure the names match up with what automap
would normally generate, in that the relationship name would be
<code class="docutils literal notranslate"><span class="pre">User.address_collection</span></code> and the name of the class referred to, from
automap’s perspective, is called <code class="docutils literal notranslate"><span class="pre">address</span></code>, even though we are referring to
it as <code class="docutils literal notranslate"><span class="pre">Address</span></code> within our usage of this class.</p>
</section>
<section id="overriding-naming-schemes">
<h2>Overriding Naming Schemes<a class="headerlink" href="#overriding-naming-schemes" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">automap</span></code></a> is tasked with producing mapped classes and
relationship names based on a schema, which means it has decision points in how
these names are determined.  These three decision points are provided using
functions which can be passed to the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method, and
are known as <a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table" title="sqlalchemy.ext.automap.classname_for_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a>,
<a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a>,
and <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="sqlalchemy.ext.automap.name_for_collection_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a>.  Any or all of these
functions are provided as in the example below, where we use a “camel case”
scheme for class names and a “pluralizer” for collection names using the
<a class="reference external" href="https://pypi.org/project/inflect">Inflect</a> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">inflect</span>


<span class="k">def</span> <span class="nf">camelize_classname</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="s2">&quot;Produce a &#39;camelized&#39; class name, e.g.&quot;</span>
    <span class="s2">&quot;&#39;words_and_underscores&#39; -&gt; &#39;WordsAndUnderscores&#39;&quot;</span>

    <span class="k">return</span> <span class="n">str</span><span class="p">(</span>
        <span class="n">tablename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;_([a-z])&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
            <span class="n">tablename</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="n">_pluralizer</span> <span class="o">=</span> <span class="n">inflect</span><span class="o">.</span><span class="n">engine</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">pluralize_collection</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
    <span class="s2">&quot;Produce an &#39;uncamelized&#39;, &#39;pluralized&#39; class name, e.g.&quot;</span>
    <span class="s2">&quot;&#39;SomeTerm&#39; -&gt; &#39;some_terms&#39;&quot;</span>

    <span class="n">referred_name</span> <span class="o">=</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">uncamelized</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;[A-Z]&quot;</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
        <span class="n">referred_name</span><span class="p">,</span>
    <span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">pluralized</span> <span class="o">=</span> <span class="n">_pluralizer</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span><span class="n">uncamelized</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pluralized</span>


<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">automap_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span>
    <span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
    <span class="n">classname_for_table</span><span class="o">=</span><span class="n">camelize_classname</span><span class="p">,</span>
    <span class="n">name_for_collection_relationship</span><span class="o">=</span><span class="n">pluralize_collection</span><span class="p">,</span>
<span class="p">)</span></pre></div>
</div>
<p>From the above mapping, we would now have classes <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code>,
where the collection from <code class="docutils literal notranslate"><span class="pre">User</span></code> to <code class="docutils literal notranslate"><span class="pre">Address</span></code> is called
<code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">Address</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">addresses</span><span class="o">=</span><span class="p">[</span><span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s2">&quot;foo@bar.com&quot;</span><span class="p">)])</span></pre></div>
</div>
</section>
<section id="relationship-detection">
<h2>Relationship Detection<a class="headerlink" href="#relationship-detection" title="Link to this heading">¶</a></h2>
<p>The vast majority of what automap accomplishes is the generation of
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> structures based on foreign keys.  The mechanism
by which this works for many-to-one and one-to-many relationships is as
follows:</p>
<ol class="arabic simple">
<li><p>A given <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, known to be mapped to a particular class,
is examined for <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> objects.</p></li>
<li><p>From each <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>, the remote
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
object present is matched up to the class to which it is to be mapped,
if any, else it is skipped.</p></li>
<li><p>As the <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
we are examining corresponds to a
reference from the immediate mapped class,  the relationship will be set up
as a many-to-one referring to the referred class; a corresponding
one-to-many backref will be created on the referred class referring
to this class.</p></li>
<li><p>If any of the columns that are part of the
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
are not nullable (e.g. <code class="docutils literal notranslate"><span class="pre">nullable=False</span></code>), a
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.cascade" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade</span></code></a> keyword argument
of <code class="docutils literal notranslate"><span class="pre">all,</span> <span class="pre">delete-orphan</span></code> will be added to the keyword arguments to
be passed to the relationship or backref.  If the
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> reports that
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ForeignKeyConstraint.ondelete</span></code></a>
is set to <code class="docutils literal notranslate"><span class="pre">CASCADE</span></code> for a not null or <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">NULL</span></code> for a nullable
set of columns, the option <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.passive_deletes</span></code></a>
flag is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> in the set of relationship keyword arguments.
Note that not all backends support reflection of ON DELETE.</p></li>
<li><p>The names of the relationships are determined using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_scalar_relationship</span></code></a> and
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_collection_relationship</span></code></a>
callable functions.  It is important to note that the default relationship
naming derives the name from the <strong>the actual class name</strong>.  If you’ve
given a particular class an explicit name by declaring it, or specified an
alternate class naming scheme, that’s the name from which the relationship
name will be derived.</p></li>
<li><p>The classes are inspected for an existing mapped property matching these
names.  If one is detected on one side, but none on the other side,
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> attempts to create a relationship on the missing side,
then uses the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a>
parameter in order to
point the new relationship to the other side.</p></li>
<li><p>In the usual case where no relationship is on either side,
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> produces a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> on the
“many-to-one” side and matches it to the other using the
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.backref</span></code></a> parameter.</p></li>
<li><p>Production of the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> and optionally the
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
is handed off to the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.generate_relationship</span></code></a>
function, which can be supplied by the end-user in order to augment
the arguments passed to <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> or to
make use of custom implementations of these functions.</p></li>
</ol>
<section id="custom-relationship-arguments">
<h3>Custom Relationship Arguments<a class="headerlink" href="#custom-relationship-arguments" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.generate_relationship</span></code></a> hook can be used
to add parameters to relationships.  For most cases, we can make use of the
existing <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a> function to return
the object, after augmenting the given keyword dictionary with our own
arguments.</p>
<p>Below is an illustration of how to send
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.cascade" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade</span></code></a> and
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.passive_deletes</span></code></a>
options along to all one-to-many relationships:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">generate_relationship</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">interfaces</span>


<span class="k">def</span> <span class="nf">_gen_relationship</span><span class="p">(</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_fn</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">ONETOMANY</span><span class="p">:</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;cascade&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all, delete-orphan&quot;</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;passive_deletes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># make use of the built-in function to actually return</span>
    <span class="c1"># the result.</span>
    <span class="k">return</span> <span class="n">generate_relationship</span><span class="p">(</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_fn</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
    <span class="p">)</span>


<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="c1"># automap base</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">generate_relationship</span><span class="o">=</span><span class="n">_gen_relationship</span><span class="p">)</span></pre></div>
</div>
</section>
<section id="many-to-many-relationships">
<h3>Many-to-Many relationships<a class="headerlink" href="#many-to-many-relationships" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">automap</span></code></a> will generate many-to-many relationships, e.g.
those which contain a <code class="docutils literal notranslate"><span class="pre">secondary</span></code> argument.  The process for producing these
is as follows:</p>
<ol class="arabic simple">
<li><p>A given <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> is examined for
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
objects, before any mapped class has been assigned to it.</p></li>
<li><p>If the table contains two and exactly two
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
objects, and all columns within this table are members of these two
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> objects, the table is assumed to be a
“secondary” table, and will <strong>not be mapped directly</strong>.</p></li>
<li><p>The two (or one, for self-referential) external tables to which the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
refers to are matched to the classes to which they will be
mapped, if any.</p></li>
<li><p>If mapped classes for both sides are located, a many-to-many bi-directional
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> / <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
pair is created between the two
classes.</p></li>
<li><p>The override logic for many-to-many works the same as that of one-to-many/
many-to-one; the <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a> function is called upon
to generate the structures and existing attributes will be maintained.</p></li>
</ol>
</section>
<section id="relationships-with-inheritance">
<h3>Relationships with Inheritance<a class="headerlink" href="#relationships-with-inheritance" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">automap</span></code></a> will not generate any relationships between
two classes that are in an inheritance relationship.   That is, with two
classes given as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;employee&quot;</span><span class="p">,</span>
        <span class="s2">&quot;polymorphic_on&quot;</span><span class="p">:</span> <span class="n">type</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;employee.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;engineer&quot;</span><span class="p">,</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>The foreign key from <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> to <code class="docutils literal notranslate"><span class="pre">Employee</span></code> is used not for a
relationship, but to establish joined inheritance between the two classes.</p>
<p>Note that this means automap will not generate <em>any</em> relationships
for foreign keys that link from a subclass to a superclass.  If a mapping
has actual relationships from subclass to superclass as well, those
need to be explicit.  Below, as we have two separate foreign keys
from <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> to <code class="docutils literal notranslate"><span class="pre">Employee</span></code>, we need to set up both the relationship
we want as well as the <code class="docutils literal notranslate"><span class="pre">inherit_condition</span></code>, as these are not things
SQLAlchemy can guess:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;employee&quot;</span><span class="p">,</span>
        <span class="s2">&quot;polymorphic_on&quot;</span><span class="p">:</span> <span class="n">type</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;employee.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">favorite_employee_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;employee.id&quot;</span><span class="p">))</span>

    <span class="n">favorite_employee</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="n">favorite_employee_id</span><span class="p">)</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;engineer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;inherit_condition&quot;</span><span class="p">:</span> <span class="n">id</span> <span class="o">==</span> <span class="n">Employee</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</section>
<section id="handling-simple-naming-conflicts">
<h3>Handling Simple Naming Conflicts<a class="headerlink" href="#handling-simple-naming-conflicts" title="Link to this heading">¶</a></h3>
<p>In the case of naming conflicts during mapping, override any of
<a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table" title="sqlalchemy.ext.automap.classname_for_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a>, <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a>,
and <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="sqlalchemy.ext.automap.name_for_collection_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a> as needed.  For example, if
automap is attempting to name a many-to-one relationship the same as an
existing column, an alternate convention can be conditionally selected.  Given
a schema:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">table_a</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">table_b</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">table_a</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="p">(</span><span class="n">table_a</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">table_a</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></pre></div>
</div>
<p>The above schema will first automap the <code class="docutils literal notranslate"><span class="pre">table_a</span></code> table as a class named
<code class="docutils literal notranslate"><span class="pre">table_a</span></code>; it will then automap a relationship onto the class for <code class="docutils literal notranslate"><span class="pre">table_b</span></code>
with the same name as this related class, e.g. <code class="docutils literal notranslate"><span class="pre">table_a</span></code>.  This
relationship name conflicts with the mapping column <code class="docutils literal notranslate"><span class="pre">table_b.table_a</span></code>,
and will emit an error on mapping.</p>
<p>We can resolve this conflict by using an underscore as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">name_for_scalar_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">local_table</span> <span class="o">=</span> <span class="n">local_cls</span><span class="o">.</span><span class="n">__table__</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">local_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">newname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Already detected name </span><span class="si">%s</span><span class="s2"> present.  using </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">newname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">newname</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span>
    <span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
    <span class="n">name_for_scalar_relationship</span><span class="o">=</span><span class="n">name_for_scalar_relationship</span><span class="p">,</span>
<span class="p">)</span></pre></div>
</div>
<p>Alternatively, we can change the name on the column side.   The columns
that are mapped can be modified using the technique described at
<a class="reference internal" href="../declarative_tables.html#mapper-column-distinct-names"><span class="std std-ref">Naming Declarative Mapped Columns Explicitly</span></a>, by assigning the column explicitly
to a new name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">TableB</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;table_b&quot;</span>
    <span class="n">_table_a</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;table_a&quot;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;table_a.id&quot;</span><span class="p">))</span>


<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</section>
</section>
<section id="using-automap-with-explicit-declarations">
<h2>Using Automap with Explicit Declarations<a class="headerlink" href="#using-automap-with-explicit-declarations" title="Link to this heading">¶</a></h2>
<p>As noted previously, automap has no dependency on reflection, and can make
use of any collection of <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects within a
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
collection.  From this, it follows that automap can also be used
generate missing relationships given an otherwise complete model that fully
defines table metadata:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="kn">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user.id&quot;</span><span class="p">))</span>


<span class="c1"># produce relationships</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c1"># mapping is complete, with &quot;address_collection&quot; and</span>
<span class="c1"># &quot;user&quot; relationships</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s2">&quot;u1&quot;</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s2">&quot;u2&quot;</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">address_collection</span><span class="o">=</span><span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="n">u1</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>Above, given mostly complete <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> mappings, the
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> which we defined on <code class="docutils literal notranslate"><span class="pre">Address.user_id</span></code> allowed a
bidirectional relationship pair <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> and
<code class="docutils literal notranslate"><span class="pre">User.address_collection</span></code> to be generated on the mapped classes.</p>
<p>Note that when subclassing <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a>,
the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method is required; if not called, the classes
we’ve declared are in an un-mapped state.</p>
</section>
<section id="intercepting-column-definitions">
<span id="automap-intercepting-columns"></span><h2>Intercepting Column Definitions<a class="headerlink" href="#intercepting-column-definitions" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> and <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects support an
event hook <a class="reference internal" href="../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a> that may be used to intercept
the information reflected about a database column before the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>
object is constructed.   For example if we wanted to map columns using a
naming convention such as <code class="docutils literal notranslate"><span class="pre">&quot;attr_&lt;columnname&gt;&quot;</span></code>, the event could
be applied as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="s2">&quot;column_reflect&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">column_reflect</span><span class="p">(</span><span class="n">inspector</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">column_info</span><span class="p">):</span>
    <span class="c1"># set column.key = &quot;attr_&lt;lower_case_name&gt;&quot;</span>
    <span class="n">column_info</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;attr_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">column_info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


<span class="c1"># run reflection</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0b2: </span>the <a class="reference internal" href="../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a> event
may be applied to a <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a></p>
<p><a class="reference internal" href="../declarative_tables.html#mapper-automated-reflection-schemes"><span class="std std-ref">Automating Column Naming Schemes from Reflected Tables</span></a> - in the ORM mapping documentation</p>
</div>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Link to this heading">¶</a></h2>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Object Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.ext.automap.automap_base"><span class="sig-name descname">automap_base</span></a>([declarative_base], **kw)</p></td>
<td><p>Produce a declarative automap base.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><span class="sig-name descname">AutomapBase</span></a></p></td>
<td><p>Base class for an “automap” schema.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table"><span class="sig-name descname">classname_for_table</span></a>(base, tablename, table)</p></td>
<td><p>Return the class name that should be used, given the name
of a table.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship"><span class="sig-name descname">generate_relationship</span></a>(base, direction, return_fn, attrname, ..., **kw)</p></td>
<td><p>Generate a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
on behalf of two
mapped classes.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship"><span class="sig-name descname">name_for_collection_relationship</span></a>(base, local_cls, referred_cls, constraint)</p></td>
<td><p>Return the attribute name that should be used to refer from one
class to another, for a collection reference.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship"><span class="sig-name descname">name_for_scalar_relationship</span></a>(base, local_cls, referred_cls, constraint)</p></td>
<td><p>Return the attribute name that should be used to refer from one
class to another, for a scalar object reference.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.automap_base">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.ext.automap.</span></span><span class="sig-name descname"><span class="pre">automap_base</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">declarative_base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#sqlalchemy.ext.automap.automap_base" title="Link to this definition">¶</a></dt>
<dd><p>Produce a declarative automap base.</p>
<p>This function produces a new base class that is a product of the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class as well a declarative base produced by
<code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code>.</p>
<p>All parameters other than <code class="docutils literal notranslate"><span class="pre">declarative_base</span></code> are keyword arguments
that are passed directly to the <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code>
function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.automap_base.params.declarative_base"></span><strong>declarative_base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.automap_base.params.declarative_base">¶</a> – an existing class produced by
<code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code>.  When this is passed, the function
no longer invokes <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code> itself, and all
other keyword arguments are ignored.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.automap_base.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.automap_base.params.**kw">¶</a> – keyword arguments are passed along to
<code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.AutomapBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.ext.automap.</span></span><span class="sig-name descname"><span class="pre">AutomapBase</span></span><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase" title="Link to this definition">¶</a></dt>
<dd><p>Base class for an “automap” schema.</p>
<p>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class can be compared to the “declarative base”
class that is produced by the <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code>
function.  In practice, the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class is always used
as a mixin along with an actual declarative base.</p>
<p>A new subclassable <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> is typically instantiated
using the <a class="reference internal" href="#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a> function.</p>
<div class="class-members docutils container">
<p><strong>Members</strong></p>
<p><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module"><span class="sig-name descname">by_module</span></a>, <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.classes"><span class="sig-name descname">classes</span></a>, <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.metadata"><span class="sig-name descname">metadata</span></a>, <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare"><span class="sig-name descname">prepare()</span></a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#"><span class="std std-ref">Automap</span></a></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.AutomapBase.by_module">
<em class="property"><span class="pre">attribute</span> </em><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap.AutomapBase.</span></code></a><span class="sig-name descname"><span class="pre">by_module</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ClassVar</span><span class="p"><span class="pre">[</span></span><span class="pre">ByModuleProperties</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="Link to this definition">¶</a></dt>
<dd><p>An instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Properties</span></code> containing a hierarchal
structure of dot-separated module names linked to classes.</p>
<p>This collection is an alternative to the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="sqlalchemy.ext.automap.AutomapBase.classes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.classes</span></code></a>
collection that is useful when making use of the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.modulename_for_table</span></code></a> parameter, which will
apply distinct <code class="docutils literal notranslate"><span class="pre">__module__</span></code> attributes to generated classes.</p>
<p>The default <code class="docutils literal notranslate"><span class="pre">__module__</span></code> an automap-generated class is
<code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code>; to access this namespace using
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="sqlalchemy.ext.automap.AutomapBase.by_module"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a> looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">User</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">by_module</span><span class="o">.</span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">automap</span><span class="o">.</span><span class="n">User</span></pre></div>
</div>
<p>If a class had a <code class="docutils literal notranslate"><span class="pre">__module__</span></code> of <code class="docutils literal notranslate"><span class="pre">mymodule.account</span></code>, accessing
this namespace looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">by_module</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">account</span><span class="o">.</span><span class="n">MyClass</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#automap-by-module"><span class="std std-ref">Generating Mappings from Multiple Schemas</span></a></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.AutomapBase.classes">
<em class="property"><span class="pre">attribute</span> </em><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap.AutomapBase.</span></code></a><span class="sig-name descname"><span class="pre">classes</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ClassVar</span><span class="p"><span class="pre">[</span></span><span class="pre">Properties</span><span class="p"><span class="pre">[</span></span><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="Link to this definition">¶</a></dt>
<dd><p>An instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Properties</span></code> containing classes.</p>
<p>This object behaves much like the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection on a table.  Classes
are present under the name they were given, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">autoload_with</span><span class="o">=</span><span class="n">some_engine</span><span class="p">)</span>

<span class="n">User</span><span class="p">,</span> <span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">Address</span></pre></div>
</div>
<p>For class names that overlap with a method name of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Properties</span></code>, such as <code class="docutils literal notranslate"><span class="pre">items()</span></code>, the getitem form
is also supported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">]</span></pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.AutomapBase.metadata">
<em class="property"><span class="pre">attribute</span> </em><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap.AutomapBase.</span></code></a><span class="sig-name descname"><span class="pre">metadata</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ClassVar</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><span class="pre">MetaData</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.metadata" title="Link to this definition">¶</a></dt>
<dd><p>Refers to the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection that will be used
for new <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../declarative_tables.html#orm-declarative-metadata"><span class="std std-ref">Accessing Table and Metadata</span></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.AutomapBase.prepare">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap.AutomapBase.</span></code></a><span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">autoload_with</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><span class="pre">Engine</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflect</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schema</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classname_for_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">PythonNameForTableType</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulename_for_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">PythonNameForTableType</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection_class</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_for_scalar_relationship</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NameForScalarRelationshipType</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_for_collection_relationship</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NameForCollectionRelationshipType</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_relationship</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GenerateRelationshipType</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflection_options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">_KT</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">_VT</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">immutabledict</span><span class="p"><span class="pre">[</span></span><span class="pre">_KT</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">_VT</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="Link to this definition">¶</a></dt>
<dd><p>Extract mapped classes and relationships from the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> and perform mappings.</p>
<p>For full documentation and examples see
<a class="reference internal" href="#automap-basic-use"><span class="std std-ref">Basic Use</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with"></span><strong>autoload_with</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with">¶</a> – an <a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> or
<a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> with which
to perform schema reflection; when specified, the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a> method will be invoked within
the scope of this method.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.engine"></span><strong>engine</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine">¶</a> – <p>legacy; use <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.params.autoload_with" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.autoload_with</span></code></a>.
Used to indicate the <a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> or
<a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> with which to reflect tables with,
if <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.params.reflect" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.reflect</span></code></a> is True.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.4: </span>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.engine</span></code></a> parameter is deprecated and will be removed in a future release.  Please use the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.autoload_with</span></code></a> parameter.</p>
</div>
</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect"></span><strong>reflect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect">¶</a> – <p>legacy; use <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.params.autoload_with" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.autoload_with</span></code></a>.
Indicates that <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a> should be invoked.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.4: </span>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflect</span></code></a> parameter is deprecated and will be removed in a future release.  Reflection is enabled when <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.autoload_with</span></code></a> is passed.</p>
</div>
</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table"></span><strong>classname_for_table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table">¶</a> – callable function which will be used to
produce new class names, given a table name.  Defaults to
<a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table" title="sqlalchemy.ext.automap.classname_for_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table"></span><strong>modulename_for_table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table">¶</a> – <p>callable function which will be used to
produce the effective <code class="docutils literal notranslate"><span class="pre">__module__</span></code> for an internally generated
class, to allow for multiple classes of the same name in a single
automap base which would be in different “modules”.</p>
<p>Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which will indicate that <code class="docutils literal notranslate"><span class="pre">__module__</span></code> will not
be set explicitly; the Python runtime will use the value
<code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code> for these classes.</p>
<p>When assigning <code class="docutils literal notranslate"><span class="pre">__module__</span></code> to generated classes, they can be
accessed based on dot-separated module names using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="sqlalchemy.ext.automap.AutomapBase.by_module"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a> collection.   Classes that have
an explicit <code class="docutils literal notranslate"><span class="pre">__module_</span></code> assigned using this hook do <strong>not</strong> get
placed into the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="sqlalchemy.ext.automap.AutomapBase.classes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.classes</span></code></a> collection, only
into <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.by_module" title="sqlalchemy.ext.automap.AutomapBase.by_module"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutomapBase.by_module</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#automap-by-module"><span class="std std-ref">Generating Mappings from Multiple Schemas</span></a></p>
</div>
</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship"></span><strong>name_for_scalar_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship">¶</a> – callable function which will be
used to produce relationship names for scalar relationships.  Defaults
to <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship"></span><strong>name_for_collection_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship">¶</a> – callable function which will
be used to produce relationship names for collection-oriented
relationships.  Defaults to <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="sqlalchemy.ext.automap.name_for_collection_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship"></span><strong>generate_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship">¶</a> – callable function which will be used to
actually generate <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> and <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
constructs.  Defaults to <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.collection_class"></span><strong>collection_class</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.collection_class">¶</a> – the Python collection class that will be used
when a new <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
object is created that represents a
collection.  Defaults to <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.schema"></span><strong>schema</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema">¶</a> – <p>Schema name to reflect when reflecting tables using
the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.autoload_with</span></code></a> parameter. The name
is passed to the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">MetaData.reflect.schema</span></code></a> parameter
of <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>. When omitted, the default schema
in use by the database connection is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.schema</span></code></a>
parameter supports reflection of a single schema at a time.
In order to include tables from many schemas, use
multiple calls to <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a>.</p>
<p>For an overview of multiple-schema automap including the use
of additional naming conventions to resolve table name
conflicts, see the section <a class="reference internal" href="#automap-by-module"><span class="std std-ref">Generating Mappings from Multiple Schemas</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> supports being
directly invoked any number of times, keeping track of tables
that have already been processed to avoid processing them
a second time.</p>
</div>
</div>
</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.reflection_options"></span><strong>reflection_options</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflection_options">¶</a> – <p>When present, this dictionary of options
will be passed to <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>
to supply general reflection-specific options like <code class="docutils literal notranslate"><span class="pre">only</span></code> and/or
dialect-specific options like <code class="docutils literal notranslate"><span class="pre">oracle_resolve_synonyms</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.</span></p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.classname_for_table">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.ext.automap.</span></span><span class="sig-name descname"><span class="pre">classname_for_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tablename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><span class="pre">Table</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#sqlalchemy.ext.automap.classname_for_table" title="Link to this definition">¶</a></dt>
<dd><p>Return the class name that should be used, given the name
of a table.</p>
<p>The default implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">str</span><span class="p">(</span><span class="n">tablename</span><span class="p">)</span></pre></div>
</div>
<p>Alternate implementations can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.classname_for_table</span></code></a>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.tablename"></span><strong>tablename</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.tablename">¶</a> – string name of the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.table"></span><strong>table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.table">¶</a> – the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object itself.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a string class name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Python 2, the string used for the class name <strong>must</strong> be a
non-Unicode object, e.g. a <code class="docutils literal notranslate"><span class="pre">str()</span></code> object.  The <code class="docutils literal notranslate"><span class="pre">.name</span></code> attribute
of <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> is typically a Python unicode subclass,
so the
<code class="docutils literal notranslate"><span class="pre">str()</span></code> function should be applied to this name, after accounting for
any non-ASCII characters.</p>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.name_for_scalar_relationship">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.ext.automap.</span></span><span class="sig-name descname"><span class="pre">name_for_scalar_relationship</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">referred_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.sql.schema.ForeignKeyConstraint"><span class="pre">ForeignKeyConstraint</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="Link to this definition">¶</a></dt>
<dd><p>Return the attribute name that should be used to refer from one
class to another, for a scalar object reference.</p>
<p>The default implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></pre></div>
</div>
<p>Alternate implementations can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_scalar_relationship</span></code></a>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.local_cls">¶</a> – the class to be mapped on the local side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.referred_cls">¶</a> – the class to be mapped on the referring side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.constraint"></span><strong>constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.constraint">¶</a> – the <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> that is being
inspected to produce this relationship.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.name_for_collection_relationship">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.ext.automap.</span></span><span class="sig-name descname"><span class="pre">name_for_collection_relationship</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">referred_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.sql.schema.ForeignKeyConstraint"><span class="pre">ForeignKeyConstraint</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="Link to this definition">¶</a></dt>
<dd><p>Return the attribute name that should be used to refer from one
class to another, for a collection reference.</p>
<p>The default implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;_collection&quot;</span></pre></div>
</div>
<p>Alternate implementations
can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_collection_relationship</span></code></a>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.local_cls">¶</a> – the class to be mapped on the local side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.referred_cls">¶</a> – the class to be mapped on the referring side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.constraint"></span><strong>constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.constraint">¶</a> – the <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> that is being
inspected to produce this relationship.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.ext.automap.generate_relationship">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.ext.automap.</span></span><span class="sig-name descname"><span class="pre">generate_relationship</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../internals.html#sqlalchemy.orm.RelationshipDirection" title="sqlalchemy.orm.RelationshipDirection"><span class="pre">RelationshipDirection</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_fn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../internals.html#sqlalchemy.orm.Relationship" title="sqlalchemy.orm.Relationship"><span class="pre">Relationship</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ORMBackrefArgument</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrname</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">referred_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../internals.html#sqlalchemy.orm.Relationship" title="sqlalchemy.orm.Relationship"><span class="pre">Relationship</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ORMBackrefArgument</span></span></span><a class="headerlink" href="#sqlalchemy.ext.automap.generate_relationship" title="Link to this definition">¶</a></dt>
<dd><p>Generate a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
on behalf of two
mapped classes.</p>
<p>An alternate implementation of this function can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.generate_relationship</span></code></a> parameter.</p>
<p>The default implementation of this function is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">return_fn</span> <span class="ow">is</span> <span class="n">backref</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">return_fn</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">return_fn</span> <span class="ow">is</span> <span class="n">relationship</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">return_fn</span><span class="p">(</span><span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown relationship function: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">return_fn</span><span class="p">)</span></pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.direction"></span><strong>direction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.direction">¶</a> – indicate the “direction” of the relationship; this will
be one of <code class="xref py py-data docutils literal notranslate"><span class="pre">ONETOMANY</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">MANYTOONE</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">MANYTOMANY</span></code>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.return_fn"></span><strong>return_fn</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn">¶</a> – the function that is used by default to create the
relationship.  This will be either <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>.  The <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> function’s result will be used to
produce a new <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> in a second step,
so it is critical
that user-defined implementations correctly differentiate between the two
functions, if a custom relationship function is being used.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.attrname"></span><strong>attrname</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.attrname">¶</a> – the attribute name to which this relationship is being
assigned. If the value of <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">generate_relationship.return_fn</span></code></a> is
the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> function, then this name is the name that is being
assigned to the backref.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.local_cls">¶</a> – the “local” class to which this relationship or backref
will be locally present.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.referred_cls">¶</a> – the “referred” class to which the relationship or
backref refers to.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.**kw">¶</a> – all additional keyword arguments are passed along to the
function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> construct,
as dictated
by the <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">generate_relationship.return_fn</span></code></a> parameter.</p>
</dd>
</dl>
</dd></dl>

</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="associationproxy.html" title="previous chapter">Association Proxy</a>
        Next:
        <a href="baked.html" title="next chapter">Baked Queries</a>

    <div id="docs-copyright">
        &copy; <a href="../../copyright.html">Copyright</a> 2007-2024, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.2.6.

    Documentation last generated: Mon 05 Aug 2024 08:14:11 PM  JST

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      document.documentElement.dataset.content_root = '../../';

    </script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../../_static/init.js"></script>


    </body>
</html>



<!DOCTYPE html>



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    Collection Customization and API Details
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="Relationship Configuration" href="relationships.html" />
        <link rel="next" title="Special Relationship Persistence Patterns" href="relationship_persistence.html" />
        <link rel="prev" title="Working with Large Collections" href="large_collections.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.31</span>


        | Release Date: June 18, 2024

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM Quick Start</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM Mapped Class Configuration</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationships.html">Relationship Configuration</a></span><ul>
<li><span class="link-container"><a class="reference external" href="basic_relationships.html">Basic Relationship Patterns</a></span></li>
<li><span class="link-container"><a class="reference external" href="self_referential.html">Adjacency List Relationships</a></span></li>
<li><span class="link-container"><a class="reference external" href="join_conditions.html">Configuring how Relationship Joins</a></span></li>
<li><span class="link-container"><a class="reference external" href="large_collections.html">Working with Large Collections</a></span></li>
<li class="selected"><span class="link-container"><strong>Collection Customization and API Details</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#customizing-collection-access">Customizing Collection Access</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#dictionary-collections">Dictionary Collections</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#dealing-with-key-mutations-and-back-populating-for-dictionary-collections">Dealing with Key Mutations and back-populating for Dictionary collections</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#custom-collection-implementations">Custom Collection Implementations</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#annotating-custom-collections-via-decorators">Annotating Custom Collections via Decorators</a></span></li>
<li><span class="link-container"><a class="reference external" href="#custom-dictionary-based-collections">Custom Dictionary-Based Collections</a></span></li>
<li><span class="link-container"><a class="reference external" href="#instrumentation-and-custom-types">Instrumentation and Custom Types</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#collection-api">Collection API</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.attribute_keyed_dict"><code class="docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.column_keyed_dict"><code class="docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.keyfunc_mapping"><code class="docutils literal notranslate"><span class="pre">keyfunc_mapping()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.attribute_mapped_collection"><code class="docutils literal notranslate"><span class="pre">attribute_mapped_collection</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.column_mapped_collection"><code class="docutils literal notranslate"><span class="pre">column_mapped_collection</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.mapped_collection"><code class="docutils literal notranslate"><span class="pre">mapped_collection</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.__init__"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.__init__()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.clear"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.clear()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.pop"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.pop()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.popitem"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.popitem()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.remove"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.remove()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.set"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.set()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.setdefault"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.setdefault()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.KeyFuncDict.update"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.update()</span></code></a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.MappedCollection"><code class="docutils literal notranslate"><span class="pre">MappedCollection</span></code></a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#collection-internals">Collection Internals</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.bulk_replace"><code class="docutils literal notranslate"><span class="pre">bulk_replace()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">collection</span></code></a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.adds"><code class="docutils literal notranslate"><span class="pre">collection.adds()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.appender"><code class="docutils literal notranslate"><span class="pre">collection.appender()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.converter"><code class="docutils literal notranslate"><span class="pre">collection.converter()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.internally_instrumented"><code class="docutils literal notranslate"><span class="pre">collection.internally_instrumented()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.iterator"><code class="docutils literal notranslate"><span class="pre">collection.iterator()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.remover"><code class="docutils literal notranslate"><span class="pre">collection.remover()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.removes"><code class="docutils literal notranslate"><span class="pre">collection.removes()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.removes_return"><code class="docutils literal notranslate"><span class="pre">collection.removes_return()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection.replaces"><code class="docutils literal notranslate"><span class="pre">collection.replaces()</span></code></a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.collection_adapter"><code class="docutils literal notranslate"><span class="pre">collection_adapter</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.CollectionAdapter"><code class="docutils literal notranslate"><span class="pre">CollectionAdapter</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.InstrumentedDict"><code class="docutils literal notranslate"><span class="pre">InstrumentedDict</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.InstrumentedList"><code class="docutils literal notranslate"><span class="pre">InstrumentedList</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.InstrumentedSet"><code class="docutils literal notranslate"><span class="pre">InstrumentedSet</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy.orm.collections.prepare_instrumentation"><code class="docutils literal notranslate"><span class="pre">prepare_instrumentation()</span></code></a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationship_persistence.html">Special Relationship Persistence Patterns</a></span></li>
<li><span class="link-container"><a class="reference external" href="backref.html">Using the legacy ‘backref’ relationship parameter</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationship_api.html">Relationships API</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM Querying Guide</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">Using the Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">Events and Internals</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM Extensions</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="large_collections.html" title="previous chapter">Working with Large Collections</a></li>
                <li><b>Next:</b>
                <a href="relationship_persistence.html" title="next chapter">Special Relationship Persistence Patterns</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="relationships.html" title="Relationship Configuration">Relationship Configuration</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#collection-customization-and-api-details">Collection Customization and API Details</a><ul>
<li><a class="reference internal" href="#customizing-collection-access">Customizing Collection Access</a><ul>
<li><a class="reference internal" href="#dictionary-collections">Dictionary Collections</a><ul>
<li><a class="reference internal" href="#dealing-with-key-mutations-and-back-populating-for-dictionary-collections">Dealing with Key Mutations and back-populating for Dictionary collections</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#custom-collection-implementations">Custom Collection Implementations</a><ul>
<li><a class="reference internal" href="#annotating-custom-collections-via-decorators">Annotating Custom Collections via Decorators</a></li>
<li><a class="reference internal" href="#custom-dictionary-based-collections">Custom Dictionary-Based Collections</a></li>
<li><a class="reference internal" href="#instrumentation-and-custom-types">Instrumentation and Custom Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collection-api">Collection API</a><ul>
<li><a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict"><code class="docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict"><code class="docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.keyfunc_mapping"><code class="docutils literal notranslate"><span class="pre">keyfunc_mapping()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.attribute_mapped_collection"><code class="docutils literal notranslate"><span class="pre">attribute_mapped_collection</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.column_mapped_collection"><code class="docutils literal notranslate"><span class="pre">column_mapped_collection</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.mapped_collection"><code class="docutils literal notranslate"><span class="pre">mapped_collection</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a><ul>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.__init__"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.__init__()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.clear"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.clear()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.pop"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.pop()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.popitem"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.popitem()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.remove"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.remove()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.set"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.set()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.setdefault"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.setdefault()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.update"><code class="docutils literal notranslate"><span class="pre">KeyFuncDict.update()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sqlalchemy.orm.MappedCollection"><code class="docutils literal notranslate"><span class="pre">MappedCollection</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#collection-internals">Collection Internals</a><ul>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.bulk_replace"><code class="docutils literal notranslate"><span class="pre">bulk_replace()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">collection</span></code></a><ul>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.adds"><code class="docutils literal notranslate"><span class="pre">collection.adds()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.appender"><code class="docutils literal notranslate"><span class="pre">collection.appender()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.converter"><code class="docutils literal notranslate"><span class="pre">collection.converter()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.internally_instrumented"><code class="docutils literal notranslate"><span class="pre">collection.internally_instrumented()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.iterator"><code class="docutils literal notranslate"><span class="pre">collection.iterator()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.remover"><code class="docutils literal notranslate"><span class="pre">collection.remover()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.removes"><code class="docutils literal notranslate"><span class="pre">collection.removes()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.removes_return"><code class="docutils literal notranslate"><span class="pre">collection.removes_return()</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection.replaces"><code class="docutils literal notranslate"><span class="pre">collection.replaces()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.collection_adapter"><code class="docutils literal notranslate"><span class="pre">collection_adapter</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.CollectionAdapter"><code class="docutils literal notranslate"><span class="pre">CollectionAdapter</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedDict"><code class="docutils literal notranslate"><span class="pre">InstrumentedDict</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedList"><code class="docutils literal notranslate"><span class="pre">InstrumentedList</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedSet"><code class="docutils literal notranslate"><span class="pre">InstrumentedSet</span></code></a></li>
<li><a class="reference internal" href="#sqlalchemy.orm.collections.prepare_instrumentation"><code class="docutils literal notranslate"><span class="pre">prepare_instrumentation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-collection_api" >
        
<section id="collection-customization-and-api-details">
<span id="custom-collections-toplevel"></span><h1>Collection Customization and API Details<a class="headerlink" href="#collection-customization-and-api-details" title="Link to this heading">¶</a></h1>
<p>The <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> function defines a linkage between two classes.
When the linkage defines a one-to-many or many-to-many relationship, it’s
represented as a Python collection when objects are loaded and manipulated.
This section presents additional information about collection configuration
and techniques.</p>
<section id="customizing-collection-access">
<span id="custom-collections"></span><h2>Customizing Collection Access<a class="headerlink" href="#customizing-collection-access" title="Link to this heading">¶</a></h2>
<p>Mapping a one-to-many or many-to-many relationship results in a collection of
values accessible through an attribute on the parent instance.   The two
common collection types for these are <code class="docutils literal notranslate"><span class="pre">list</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code>, which in
<a class="reference internal" href="declarative_styles.html"><span class="std std-ref">Declarative</span></a> mappings that use
<a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> is established by using the collection type within
the <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> container, as demonstrated in the <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> collection
below where <code class="docutils literal notranslate"><span class="pre">list</span></code> is used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">ForeignKey</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>

    <span class="n">parent_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># use a list</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Child&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>

    <span class="n">child_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Or for a <code class="docutils literal notranslate"><span class="pre">set</span></code>, illustrated in the same
<code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> collection:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Set</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">ForeignKey</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>

    <span class="n">parent_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># use a set</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="s2">&quot;Child&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>

    <span class="n">child_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span></pre><div class="code-annotations-key"></div></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using Python 3.7 or 3.8, annotations for collections need
to use <code class="docutils literal notranslate"><span class="pre">typing.List</span></code> or <code class="docutils literal notranslate"><span class="pre">typing.Set</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">Mapped[List[&quot;Child&quot;]]</span></code> or
<code class="docutils literal notranslate"><span class="pre">Mapped[Set[&quot;Child&quot;]]</span></code>; the <code class="docutils literal notranslate"><span class="pre">list</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> Python built-ins
don’t yet support generic annotation in these Python versions, such as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>

    <span class="n">parent_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># use a List, Python 3.8 and earlier</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Child&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">()</span></pre><div class="code-annotations-key"></div></div>
</div>
</div>
<p>When using mappings without the <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> annotation, such as when
using <a class="reference internal" href="mapping_styles.html#orm-imperative-mapping"><span class="std std-ref">imperative mappings</span></a> or untyped
Python code, as well as in a few special cases, the collection class for a
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> can always be specified directly using the
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.collection_class" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code></a> parameter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># non-annotated mapping</span>


<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>

    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">,</span> <span class="n">collection_class</span><span class="o">=</span><span class="n">set</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>

    <span class="n">child_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>In the absence of <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.collection_class" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code></a>
or <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>, the default collection type is <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
<p>Beyond <code class="docutils literal notranslate"><span class="pre">list</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> builtins, there is also support for two varieties of
dictionary, described below at <a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a>. There is also
support for any arbitrary mutable sequence type can be set up as the target
collection, with some additional configuration steps; this is described in the
section <a class="reference internal" href="#orm-custom-collection"><span class="std std-ref">Custom Collection Implementations</span></a>.</p>
<section id="dictionary-collections">
<span id="orm-dictionary-collection"></span><h3>Dictionary Collections<a class="headerlink" href="#dictionary-collections" title="Link to this heading">¶</a></h3>
<p>A little extra detail is needed when using a dictionary as a collection.
This because objects are always loaded from the database as lists, and a key-generation
strategy must be available to populate the dictionary correctly.  The
<a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> function is by far the most common way
to achieve a simple dictionary collection.  It produces a dictionary class that will apply a particular attribute
of the mapped class as a key.   Below we map an <code class="docutils literal notranslate"><span class="pre">Item</span></code> class containing
a dictionary of <code class="docutils literal notranslate"><span class="pre">Note</span></code> items keyed to the <code class="docutils literal notranslate"><span class="pre">Note.keyword</span></code> attribute.
When using <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a>, the <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>
annotation may be typed using the <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a>
or just plain <code class="docutils literal notranslate"><span class="pre">dict</span></code> as illustrated in the following example.   However,
the <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.collection_class" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code></a> parameter
is required in this case so that the <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a>
may be appropriately parametrized:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">attribute_keyed_dict</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;item&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">notes</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="s2">&quot;Note&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">collection_class</span><span class="o">=</span><span class="n">attribute_keyed_dict</span><span class="p">(</span><span class="s2">&quot;keyword&quot;</span><span class="p">),</span>
        <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete-orphan&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Note</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;note&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">item_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;item.id&quot;</span><span class="p">))</span>
    <span class="n">keyword</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>
    <span class="n">text</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">str</span><span class="p">]]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span></pre><div class="code-annotations-key"></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Item.notes</span></code> is then a dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">item</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Note</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;atext&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">item</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: &lt;__main__.Note object at 0x2eaaf0&gt;}</span></pre></div>
</div>
<p><a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> will ensure that
the <code class="docutils literal notranslate"><span class="pre">.keyword</span></code> attribute of each <code class="docutils literal notranslate"><span class="pre">Note</span></code> complies with the key in the
dictionary.   Such as, when assigning to <code class="docutils literal notranslate"><span class="pre">Item.notes</span></code>, the dictionary
key we supply must match that of the actual <code class="docutils literal notranslate"><span class="pre">Note</span></code> object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">()</span>
<span class="n">item</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">Note</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;atext&quot;</span><span class="p">),</span>
    <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="n">Note</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;btext&quot;</span><span class="p">),</span>
<span class="p">}</span></pre></div>
</div>
<p>The attribute which <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> uses as a key
does not need to be mapped at all!  Using a regular Python <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> allows virtually
any detail or combination of details about the object to be used as the key, as
below when we establish it as a tuple of <code class="docutils literal notranslate"><span class="pre">Note.keyword</span></code> and the first ten letters
of the <code class="docutils literal notranslate"><span class="pre">Note.text</span></code> field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;item&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">notes</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="s2">&quot;Note&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">collection_class</span><span class="o">=</span><span class="n">attribute_keyed_dict</span><span class="p">(</span><span class="s2">&quot;note_key&quot;</span><span class="p">),</span>
        <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;item&quot;</span><span class="p">,</span>
        <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete-orphan&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Note</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;note&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">item_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;item.id&quot;</span><span class="p">))</span>
    <span class="n">keyword</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>
    <span class="n">text</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>

    <span class="n">item</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;Item&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">note_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Above we added a <code class="docutils literal notranslate"><span class="pre">Note.item</span></code> relationship, with a bi-directional
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> configuration.
Assigning to this reverse relationship, the <code class="docutils literal notranslate"><span class="pre">Note</span></code>
is added to the <code class="docutils literal notranslate"><span class="pre">Item.notes</span></code> dictionary and the key is generated for us automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span> <span class="o">=</span> <span class="n">Note</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;atext&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">item</span><span class="o">.</span><span class="n">notes</span>
<span class="go">{(&#39;a&#39;, &#39;atext&#39;): &lt;__main__.Note object at 0x2eaaf0&gt;}</span></pre></div>
</div>
<p>Other built-in dictionary types include <a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a>,
which is almost like <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> except given the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>
object directly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">column_keyed_dict</span>


<span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;item&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">notes</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="s2">&quot;Note&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">collection_class</span><span class="o">=</span><span class="n">column_keyed_dict</span><span class="p">(</span><span class="n">Note</span><span class="o">.</span><span class="n">__table__</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">keyword</span><span class="p">),</span>
        <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete-orphan&quot;</span><span class="p">,</span>
    <span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>as well as <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_collection()</span></code> which is passed any callable function.
Note that it’s usually easier to use <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> along
with a <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> as mentioned earlier:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_collection</span>


<span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;item&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">notes</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="s2">&quot;Note&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">collection_class</span><span class="o">=</span><span class="n">mapped_collection</span><span class="p">(</span><span class="k">lambda</span> <span class="n">note</span><span class="p">:</span> <span class="n">note</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]),</span>
        <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete-orphan&quot;</span><span class="p">,</span>
    <span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Dictionary mappings are often combined with the “Association Proxy” extension to produce
streamlined dictionary views.  See <a class="reference internal" href="extensions/associationproxy.html#proxying-dictionaries"><span class="std std-ref">Proxying to Dictionary Based Collections</span></a> and <a class="reference internal" href="extensions/associationproxy.html#composite-association-proxy"><span class="std std-ref">Composite Association Proxies</span></a>
for examples.</p>
<section id="dealing-with-key-mutations-and-back-populating-for-dictionary-collections">
<span id="key-collections-mutations"></span><h4>Dealing with Key Mutations and back-populating for Dictionary collections<a class="headerlink" href="#dealing-with-key-mutations-and-back-populating-for-dictionary-collections" title="Link to this heading">¶</a></h4>
<p>When using <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a>, the “key” for the dictionary
is taken from an attribute on the target object.   <strong>Changes to this key
are not tracked</strong>.  This means that the key must be assigned towards when
it is first used, and if the key changes, the collection will not be mutated.
A typical example where this might be an issue is when relying upon backrefs
to populate an attribute mapped collection.  Given the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">bs</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">collection_class</span><span class="o">=</span><span class="n">attribute_keyed_dict</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">),</span>
        <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;a.id&quot;</span><span class="p">))</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>

    <span class="n">a</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;bs&quot;</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Above, if we create a <code class="docutils literal notranslate"><span class="pre">B()</span></code> that refers to a specific <code class="docutils literal notranslate"><span class="pre">A()</span></code>, the back
populates will then add the <code class="docutils literal notranslate"><span class="pre">B()</span></code> to the <code class="docutils literal notranslate"><span class="pre">A.bs</span></code> collection, however
if the value of <code class="docutils literal notranslate"><span class="pre">B.data</span></code> is not set yet, the key will be <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">bs</span>
<span class="go">{None: &lt;test3.B object at 0x7f7b1023ef70&gt;}</span></pre></div>
</div>
<p>Setting <code class="docutils literal notranslate"><span class="pre">b1.data</span></code> after the fact does not update the collection:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;the key&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">bs</span>
<span class="go">{None: &lt;test3.B object at 0x7f7b1023ef70&gt;}</span></pre></div>
</div>
<p>This can also be seen if one attempts to set up <code class="docutils literal notranslate"><span class="pre">B()</span></code> in the constructor.
The order of arguments changes the result:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s2">&quot;the key&quot;</span><span class="p">)</span>
<span class="go">&lt;test3.B object at 0x7f7b10114280&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">bs</span>
<span class="go">{None: &lt;test3.B object at 0x7f7b10114280&gt;}</span></pre></div>
</div>
<p>vs:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;the key&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a1</span><span class="p">)</span>
<span class="go">&lt;test3.B object at 0x7f7b10114340&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">bs</span>
<span class="go">{&#39;the key&#39;: &lt;test3.B object at 0x7f7b10114340&gt;}</span></pre></div>
</div>
<p>If backrefs are being used in this way, ensure that attributes are populated
in the correct order using an <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method.</p>
<p>An event handler such as the following may also be used to track changes in the
collection as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">attributes</span>


<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;set&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">set_item</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">previous</span> <span class="o">==</span> <span class="n">attributes</span><span class="o">.</span><span class="n">NO_VALUE</span> <span class="k">else</span> <span class="n">previous</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">bs</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">bs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span></pre></div>
</div>
</section>
</section>
</section>
<section id="custom-collection-implementations">
<span id="orm-custom-collection"></span><h2>Custom Collection Implementations<a class="headerlink" href="#custom-collection-implementations" title="Link to this heading">¶</a></h2>
<p>You can use your own types for collections as well.  In simple cases,
inheriting from <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">set</span></code>, adding custom behavior, is all that’s needed.
In other cases, special decorators are needed to tell SQLAlchemy more detail
about how the collection operates.</p>
<aside class="topic">
<p class="topic-title">Do I need a custom collection implementation?</p>
<p>In most cases not at all!   The most common use cases for a “custom” collection
is one that validates or marshals incoming values into a new form, such as
a string that becomes a class instance, or one which goes a
step beyond and represents the data internally in some fashion, presenting
a “view” of that data on the outside of a different form.</p>
<p>For the first use case, the <a class="reference internal" href="mapped_attributes.html#sqlalchemy.orm.validates" title="sqlalchemy.orm.validates"><code class="xref py py-func docutils literal notranslate"><span class="pre">validates()</span></code></a> decorator is by far
the simplest way to intercept incoming values in all cases for the purposes
of validation and simple marshaling.  See <a class="reference internal" href="mapped_attributes.html#simple-validators"><span class="std std-ref">Simple Validators</span></a>
for an example of this.</p>
<p>For the second use case, the <a class="reference internal" href="extensions/associationproxy.html"><span class="std std-ref">Association Proxy</span></a> extension is a
well-tested, widely used system that provides a read/write “view” of a
collection in terms of some attribute present on the target object. As the
target attribute can be a <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> that returns virtually anything, a
wide array of “alternative” views of a collection can be constructed with
just a few functions. This approach leaves the underlying mapped collection
unaffected and avoids the need to carefully tailor collection behavior on a
method-by-method basis.</p>
<p>Customized collections are useful when the collection needs to
have special behaviors upon access or mutation operations that can’t
otherwise be modeled externally to the collection.   They can of course
be combined with the above two approaches.</p>
</aside>
<p>Collections in SQLAlchemy are transparently <em>instrumented</em>. Instrumentation
means that normal operations on the collection are tracked and result in
changes being written to the database at flush time. Additionally, collection
operations can fire <em>events</em> which indicate some secondary operation must take
place. Examples of a secondary operation include saving the child item in the
parent’s <a class="reference internal" href="session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> (i.e. the <code class="docutils literal notranslate"><span class="pre">save-update</span></code>
cascade), as well as synchronizing the state of a bi-directional relationship
(i.e. a <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>).</p>
<p>The collections package understands the basic interface of lists, sets and
dicts and will automatically apply instrumentation to those built-in types and
their subclasses. Object-derived types that implement a basic collection
interface are detected and instrumented via duck-typing:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListLike</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;foo&quot;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">append</span></code>, <code class="docutils literal notranslate"><span class="pre">remove</span></code>, and <code class="docutils literal notranslate"><span class="pre">extend</span></code> are known members of <code class="docutils literal notranslate"><span class="pre">list</span></code>, and will
be instrumented automatically. <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> is not a mutator method and won’t
be instrumented, and <code class="docutils literal notranslate"><span class="pre">foo</span></code> won’t be either.</p>
<p>Duck-typing (i.e. guesswork) isn’t rock-solid, of course, so you can be
explicit about the interface you are implementing by providing an
<code class="docutils literal notranslate"><span class="pre">__emulates__</span></code> class attribute:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SetLike</span><span class="p">:</span>
    <span class="n">__emulates__</span> <span class="o">=</span> <span class="n">set</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>This class looks similar to a Python <code class="docutils literal notranslate"><span class="pre">list</span></code> (i.e. “list-like”) as it has an
<code class="docutils literal notranslate"><span class="pre">append</span></code> method, but the <code class="docutils literal notranslate"><span class="pre">__emulates__</span></code> attribute forces it to be treated
as a <code class="docutils literal notranslate"><span class="pre">set</span></code>. <code class="docutils literal notranslate"><span class="pre">remove</span></code> is known to be part of the set interface and will be
instrumented.</p>
<p>But this class won’t work quite yet: a little glue is needed to adapt it for
use by SQLAlchemy. The ORM needs to know which methods to use to append, remove
and iterate over members of the collection. When using a type like <code class="docutils literal notranslate"><span class="pre">list</span></code> or
<code class="docutils literal notranslate"><span class="pre">set</span></code>, the appropriate methods are well-known and used automatically when
present.  However the class above, which only roughly resembles a <code class="docutils literal notranslate"><span class="pre">set</span></code>, does not
provide the expected <code class="docutils literal notranslate"><span class="pre">add</span></code> method, so we must indicate to the ORM the
method that will instead take the place of the <code class="docutils literal notranslate"><span class="pre">add</span></code> method, in this
case using a decorator <code class="docutils literal notranslate"><span class="pre">&#64;collection.appender</span></code>; this is illustrated in the
next section.</p>
<section id="annotating-custom-collections-via-decorators">
<h3>Annotating Custom Collections via Decorators<a class="headerlink" href="#annotating-custom-collections-via-decorators" title="Link to this heading">¶</a></h3>
<p>Decorators can be used to tag the individual methods the ORM needs to manage
collections. Use them when your class doesn’t quite meet the regular interface
for its container type, or when you otherwise would like to use a different method to
get the job done.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm.collections</span> <span class="kn">import</span> <span class="n">collection</span>


<span class="k">class</span> <span class="nc">SetLike</span><span class="p">:</span>
    <span class="n">__emulates__</span> <span class="o">=</span> <span class="n">set</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">set</span><span class="p">()</span>

    <span class="nd">@collection</span><span class="o">.</span><span class="n">appender</span>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>And that’s all that’s needed to complete the example. SQLAlchemy will add
instances via the <code class="docutils literal notranslate"><span class="pre">append</span></code> method. <code class="docutils literal notranslate"><span class="pre">remove</span></code> and <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> are the
default methods for sets and will be used for removing and iteration. Default
methods can be changed as well:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm.collections</span> <span class="kn">import</span> <span class="n">collection</span>


<span class="k">class</span> <span class="nc">MyList</span><span class="p">(</span><span class="n">list</span><span class="p">):</span>
    <span class="nd">@collection</span><span class="o">.</span><span class="n">remover</span>
    <span class="k">def</span> <span class="nf">zark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># do something special...</span>
        <span class="o">...</span>

    <span class="nd">@collection</span><span class="o">.</span><span class="n">iterator</span>
    <span class="k">def</span> <span class="nf">hey_use_this_instead_for_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>There is no requirement to be “list-like” or “set-like” at all. Collection classes
can be any shape, so long as they have the append, remove and iterate
interface marked for SQLAlchemy’s use. Append and remove methods will be
called with a mapped entity as the single argument, and iterator methods are
called with no arguments and must return an iterator.</p>
</section>
<section id="custom-dictionary-based-collections">
<span id="id1"></span><h3>Custom Dictionary-Based Collections<a class="headerlink" href="#custom-dictionary-based-collections" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> class can be used as
a base class for your custom types or as a mix-in to quickly add <code class="docutils literal notranslate"><span class="pre">dict</span></code>
collection support to other classes. It uses a keying function to delegate to
<code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> and <code class="docutils literal notranslate"><span class="pre">__delitem__</span></code>:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm.collections</span> <span class="kn">import</span> <span class="n">KeyFuncDict</span>


<span class="k">class</span> <span class="nc">MyNodeMap</span><span class="p">(</span><span class="n">KeyFuncDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Holds &#39;Node&#39; objects, keyed by the &#39;name&#39; attribute.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keyfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">dict</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>When subclassing <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a>, user-defined versions
of <code class="docutils literal notranslate"><span class="pre">__setitem__()</span></code> or <code class="docutils literal notranslate"><span class="pre">__delitem__()</span></code> should be decorated
with <a class="reference internal" href="#sqlalchemy.orm.collections.collection.internally_instrumented" title="sqlalchemy.orm.collections.collection.internally_instrumented"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collection.internally_instrumented()</span></code></a>, <strong>if</strong> they call down
to those same methods on <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a>.  This because the methods
on <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> are already instrumented - calling them
from within an already instrumented call can cause events to be fired off
repeatedly, or inappropriately, leading to internal state corruption in
rare cases:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm.collections</span> <span class="kn">import</span> <span class="n">KeyFuncDict</span><span class="p">,</span> <span class="n">collection</span>


<span class="k">class</span> <span class="nc">MyKeyFuncDict</span><span class="p">(</span><span class="n">KeyFuncDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use @internally_instrumented when your methods</span>
<span class="sd">    call down to already-instrumented methods.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@collection</span><span class="o">.</span><span class="n">internally_instrumented</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">_sa_initiator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># do something with key, value</span>
        <span class="n">super</span><span class="p">(</span><span class="n">MyKeyFuncDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">_sa_initiator</span><span class="p">)</span>

    <span class="nd">@collection</span><span class="o">.</span><span class="n">internally_instrumented</span>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_sa_initiator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># do something with key</span>
        <span class="n">super</span><span class="p">(</span><span class="n">MyKeyFuncDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_sa_initiator</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>The ORM understands the <code class="docutils literal notranslate"><span class="pre">dict</span></code> interface just like lists and sets, and will
automatically instrument all “dict-like” methods if you choose to subclass
<code class="docutils literal notranslate"><span class="pre">dict</span></code> or provide dict-like collection behavior in a duck-typed class. You
must decorate appender and remover methods, however- there are no compatible
methods in the basic dictionary interface for SQLAlchemy to use by default.
Iteration will go through <code class="docutils literal notranslate"><span class="pre">values()</span></code> unless otherwise decorated.</p>
</section>
<section id="instrumentation-and-custom-types">
<h3>Instrumentation and Custom Types<a class="headerlink" href="#instrumentation-and-custom-types" title="Link to this heading">¶</a></h3>
<p>Many custom types and existing library classes can be used as a entity
collection type as-is without further ado. However, it is important to note
that the instrumentation process will modify the type, adding decorators
around methods automatically.</p>
<p>The decorations are lightweight and no-op outside of relationships, but they
do add unneeded overhead when triggered elsewhere. When using a library class
as a collection, it can be good practice to use the “trivial subclass” trick
to restrict the decorations to just your usage in relationships. For example:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyAwesomeList</span><span class="p">(</span><span class="n">some</span><span class="o">.</span><span class="n">great</span><span class="o">.</span><span class="n">library</span><span class="o">.</span><span class="n">AwesomeList</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># ... relationship(..., collection_class=MyAwesomeList)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>The ORM uses this approach for built-ins, quietly substituting a trivial
subclass when a <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">set</span></code> or <code class="docutils literal notranslate"><span class="pre">dict</span></code> is used directly.</p>
</section>
</section>
<section id="collection-api">
<h2>Collection API<a class="headerlink" href="#collection-api" title="Link to this heading">¶</a></h2>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Object Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict"><span class="sig-name descname">attribute_keyed_dict</span></a>(attr_name, *, [ignore_unpopulated_attribute])</p></td>
<td><p>A dictionary-based collection type with attribute-based keying.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.attribute_mapped_collection"><span class="sig-name descname">attribute_mapped_collection</span></a></p></td>
<td><p>A dictionary-based collection type with attribute-based keying.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict"><span class="sig-name descname">column_keyed_dict</span></a>(mapping_spec, *, [ignore_unpopulated_attribute])</p></td>
<td><p>A dictionary-based collection type with column-based keying.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.column_mapped_collection"><span class="sig-name descname">column_mapped_collection</span></a></p></td>
<td><p>A dictionary-based collection type with column-based keying.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.keyfunc_mapping"><span class="sig-name descname">keyfunc_mapping</span></a>(keyfunc, *, [ignore_unpopulated_attribute])</p></td>
<td><p>A dictionary-based collection type with arbitrary keying.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><span class="sig-name descname">KeyFuncDict</span></a></p></td>
<td><p>Base for ORM mapped dictionary classes.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.mapped_collection"><span class="sig-name descname">mapped_collection</span></a></p></td>
<td><p>A dictionary-based collection type with arbitrary keying.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.MappedCollection"><span class="sig-name descname">MappedCollection</span></a></p></td>
<td><p>Base for ORM mapped dictionary classes.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.orm.attribute_keyed_dict">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">attribute_keyed_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_unpopulated_attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.mapped_collection.KeyFuncDict"><span class="pre">KeyFuncDict</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#sqlalchemy.orm.attribute_keyed_dict" title="Link to this definition">¶</a></dt>
<dd><p>A dictionary-based collection type with attribute-based keying.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <a class="reference internal" href="#sqlalchemy.orm.attribute_mapped_collection" title="sqlalchemy.orm.attribute_mapped_collection"><code class="xref py py-data docutils literal notranslate"><span class="pre">attribute_mapped_collection</span></code></a> to
<a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a>.</p>
</div>
<p>Returns a <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> factory which will produce new
dictionary keys based on the value of a particular named attribute on
ORM mapped instances to be added to the dictionary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the value of the target attribute must be assigned with its
value at the time that the object is being added to the
dictionary collection.   Additionally, changes to the key attribute
are <strong>not tracked</strong>, which means the key in the dictionary is not
automatically synchronized with the key value on the target object
itself.  See <a class="reference internal" href="#key-collections-mutations"><span class="std std-ref">Dealing with Key Mutations and back-populating for Dictionary collections</span></a> for further details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a> - background on use</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.orm.attribute_keyed_dict.params.attr_name"></span><strong>attr_name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.attribute_keyed_dict.params.attr_name">¶</a> – string name of an ORM-mapped attribute
on the mapped class, the value of which on a particular instance
is to be used as the key for a new dictionary entry for that instance.</p></li>
<li><p><span class="target" id="sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute"></span><strong>ignore_unpopulated_attribute</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute">¶</a> – <p>if True, and the target attribute
on an object is not populated at all, the operation will be silently
skipped.  By default, an error is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>an error is raised by default if the attribute
being used for the dictionary key is determined that it was never
populated with any value.  The
<a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">attribute_keyed_dict.ignore_unpopulated_attribute</span></code></a>
parameter may be set which will instead indicate that this condition
should be ignored, and the append operation silently skipped.
This is in contrast to the behavior of the 1.x series which would
erroneously populate the value in the dictionary with an arbitrary key
value of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.orm.column_keyed_dict">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">column_keyed_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_spec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">_KT</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">_KT</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">_VT</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_unpopulated_attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.mapped_collection.KeyFuncDict"><span class="pre">KeyFuncDict</span></a><span class="p"><span class="pre">[</span></span><span class="pre">_KT</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">_KT</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#sqlalchemy.orm.column_keyed_dict" title="Link to this definition">¶</a></dt>
<dd><p>A dictionary-based collection type with column-based keying.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <a class="reference internal" href="#sqlalchemy.orm.column_mapped_collection" title="sqlalchemy.orm.column_mapped_collection"><code class="xref py py-data docutils literal notranslate"><span class="pre">column_mapped_collection</span></code></a> to
<code class="xref py py-class docutils literal notranslate"><span class="pre">column_keyed_dict</span></code>.</p>
</div>
<p>Returns a <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> factory which will produce new
dictionary keys based on the value of a particular <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>-mapped
attribute on ORM mapped instances to be added to the dictionary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the value of the target attribute must be assigned with its
value at the time that the object is being added to the
dictionary collection.   Additionally, changes to the key attribute
are <strong>not tracked</strong>, which means the key in the dictionary is not
automatically synchronized with the key value on the target object
itself.  See <a class="reference internal" href="#key-collections-mutations"><span class="std std-ref">Dealing with Key Mutations and back-populating for Dictionary collections</span></a> for further details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a> - background on use</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.orm.column_keyed_dict.params.mapping_spec"></span><strong>mapping_spec</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.column_keyed_dict.params.mapping_spec">¶</a> – a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> object that is expected
to be mapped by the target mapper to a particular attribute on the
mapped class, the value of which on a particular instance is to be used
as the key for a new dictionary entry for that instance.</p></li>
<li><p><span class="target" id="sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute"></span><strong>ignore_unpopulated_attribute</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute">¶</a> – <p>if True, and the mapped attribute
indicated by the given <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> target attribute
on an object is not populated at all, the operation will be silently
skipped.  By default, an error is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>an error is raised by default if the attribute
being used for the dictionary key is determined that it was never
populated with any value.  The
<a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">column_keyed_dict.ignore_unpopulated_attribute</span></code></a>
parameter may be set which will instead indicate that this condition
should be ignored, and the append operation silently skipped.
This is in contrast to the behavior of the 1.x series which would
erroneously populate the value in the dictionary with an arbitrary key
value of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.orm.keyfunc_mapping">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">keyfunc_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keyfunc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_unpopulated_attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.mapped_collection.KeyFuncDict"><span class="pre">KeyFuncDict</span></a><span class="p"><span class="pre">[</span></span><span class="pre">_KT</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#sqlalchemy.orm.keyfunc_mapping" title="Link to this definition">¶</a></dt>
<dd><p>A dictionary-based collection type with arbitrary keying.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <a class="reference internal" href="#sqlalchemy.orm.mapped_collection" title="sqlalchemy.orm.mapped_collection"><code class="xref py py-data docutils literal notranslate"><span class="pre">mapped_collection</span></code></a> to
<a class="reference internal" href="#sqlalchemy.orm.keyfunc_mapping" title="sqlalchemy.orm.keyfunc_mapping"><code class="xref py py-func docutils literal notranslate"><span class="pre">keyfunc_mapping()</span></code></a>.</p>
</div>
<p>Returns a <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> factory with a keying function
generated from keyfunc, a callable that takes an entity and returns a
key value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the given keyfunc is called only once at the time that the
target object is being added to the collection.   Changes to the
effective value returned by the function are not tracked.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a> - background on use</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.orm.keyfunc_mapping.params.keyfunc"></span><strong>keyfunc</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.keyfunc_mapping.params.keyfunc">¶</a> – a callable that will be passed the ORM-mapped instance
which should then generate a new key to use in the dictionary.
If the value returned is <a class="reference internal" href="internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE" title="sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoaderCallableStatus.NO_VALUE</span></code></a>, an error
is raised.</p></li>
<li><p><span class="target" id="sqlalchemy.orm.keyfunc_mapping.params.ignore_unpopulated_attribute"></span><strong>ignore_unpopulated_attribute</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.keyfunc_mapping.params.ignore_unpopulated_attribute">¶</a> – <p>if True, and the callable returns
<a class="reference internal" href="internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE" title="sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoaderCallableStatus.NO_VALUE</span></code></a> for a particular instance, the
operation will be silently skipped.  By default, an error is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>an error is raised by default if the callable
being used for the dictionary key returns
<a class="reference internal" href="internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE" title="sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoaderCallableStatus.NO_VALUE</span></code></a>, which in an ORM attribute
context indicates an attribute that was never populated with any value.
The <a class="reference internal" href="#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute" title="sqlalchemy.orm.mapped_collection"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_collection.ignore_unpopulated_attribute</span></code></a>
parameter may be set which will instead indicate that this condition
should be ignored, and the append operation silently skipped. This is
in contrast to the behavior of the 1.x series which would erroneously
populate the value in the dictionary with an arbitrary key value of
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlalchemy.orm.attribute_mapped_collection">
<span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">attribute_mapped_collection</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;function</span> <span class="pre">attribute_keyed_dict&gt;</span></em><a class="headerlink" href="#sqlalchemy.orm.attribute_mapped_collection" title="Link to this definition">¶</a></dt>
<dd><p>A dictionary-based collection type with attribute-based keying.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <a class="reference internal" href="#sqlalchemy.orm.attribute_mapped_collection" title="sqlalchemy.orm.attribute_mapped_collection"><code class="xref py py-data docutils literal notranslate"><span class="pre">attribute_mapped_collection</span></code></a> to
<a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a>.</p>
</div>
<p>Returns a <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> factory which will produce new
dictionary keys based on the value of a particular named attribute on
ORM mapped instances to be added to the dictionary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the value of the target attribute must be assigned with its
value at the time that the object is being added to the
dictionary collection.   Additionally, changes to the key attribute
are <strong>not tracked</strong>, which means the key in the dictionary is not
automatically synchronized with the key value on the target object
itself.  See <a class="reference internal" href="#key-collections-mutations"><span class="std std-ref">Dealing with Key Mutations and back-populating for Dictionary collections</span></a> for further details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a> - background on use</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attr_name</strong> – string name of an ORM-mapped attribute
on the mapped class, the value of which on a particular instance
is to be used as the key for a new dictionary entry for that instance.</p></li>
<li><p><strong>ignore_unpopulated_attribute</strong> – <p>if True, and the target attribute
on an object is not populated at all, the operation will be silently
skipped.  By default, an error is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>an error is raised by default if the attribute
being used for the dictionary key is determined that it was never
populated with any value.  The
<a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">attribute_keyed_dict.ignore_unpopulated_attribute</span></code></a>
parameter may be set which will instead indicate that this condition
should be ignored, and the append operation silently skipped.
This is in contrast to the behavior of the 1.x series which would
erroneously populate the value in the dictionary with an arbitrary key
value of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlalchemy.orm.column_mapped_collection">
<span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">column_mapped_collection</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;function</span> <span class="pre">column_keyed_dict&gt;</span></em><a class="headerlink" href="#sqlalchemy.orm.column_mapped_collection" title="Link to this definition">¶</a></dt>
<dd><p>A dictionary-based collection type with column-based keying.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <a class="reference internal" href="#sqlalchemy.orm.column_mapped_collection" title="sqlalchemy.orm.column_mapped_collection"><code class="xref py py-data docutils literal notranslate"><span class="pre">column_mapped_collection</span></code></a> to
<code class="xref py py-class docutils literal notranslate"><span class="pre">column_keyed_dict</span></code>.</p>
</div>
<p>Returns a <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> factory which will produce new
dictionary keys based on the value of a particular <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>-mapped
attribute on ORM mapped instances to be added to the dictionary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the value of the target attribute must be assigned with its
value at the time that the object is being added to the
dictionary collection.   Additionally, changes to the key attribute
are <strong>not tracked</strong>, which means the key in the dictionary is not
automatically synchronized with the key value on the target object
itself.  See <a class="reference internal" href="#key-collections-mutations"><span class="std std-ref">Dealing with Key Mutations and back-populating for Dictionary collections</span></a> for further details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a> - background on use</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mapping_spec</strong> – a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> object that is expected
to be mapped by the target mapper to a particular attribute on the
mapped class, the value of which on a particular instance is to be used
as the key for a new dictionary entry for that instance.</p></li>
<li><p><strong>ignore_unpopulated_attribute</strong> – <p>if True, and the mapped attribute
indicated by the given <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> target attribute
on an object is not populated at all, the operation will be silently
skipped.  By default, an error is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>an error is raised by default if the attribute
being used for the dictionary key is determined that it was never
populated with any value.  The
<a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">column_keyed_dict.ignore_unpopulated_attribute</span></code></a>
parameter may be set which will instead indicate that this condition
should be ignored, and the append operation silently skipped.
This is in contrast to the behavior of the 1.x series which would
erroneously populate the value in the dictionary with an arbitrary key
value of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlalchemy.orm.mapped_collection">
<span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">mapped_collection</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;function</span> <span class="pre">keyfunc_mapping&gt;</span></em><a class="headerlink" href="#sqlalchemy.orm.mapped_collection" title="Link to this definition">¶</a></dt>
<dd><p>A dictionary-based collection type with arbitrary keying.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <a class="reference internal" href="#sqlalchemy.orm.mapped_collection" title="sqlalchemy.orm.mapped_collection"><code class="xref py py-data docutils literal notranslate"><span class="pre">mapped_collection</span></code></a> to
<a class="reference internal" href="#sqlalchemy.orm.keyfunc_mapping" title="sqlalchemy.orm.keyfunc_mapping"><code class="xref py py-func docutils literal notranslate"><span class="pre">keyfunc_mapping()</span></code></a>.</p>
</div>
<p>Returns a <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> factory with a keying function
generated from keyfunc, a callable that takes an entity and returns a
key value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the given keyfunc is called only once at the time that the
target object is being added to the collection.   Changes to the
effective value returned by the function are not tracked.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a> - background on use</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keyfunc</strong> – a callable that will be passed the ORM-mapped instance
which should then generate a new key to use in the dictionary.
If the value returned is <a class="reference internal" href="internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE" title="sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoaderCallableStatus.NO_VALUE</span></code></a>, an error
is raised.</p></li>
<li><p><strong>ignore_unpopulated_attribute</strong> – <p>if True, and the callable returns
<a class="reference internal" href="internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE" title="sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoaderCallableStatus.NO_VALUE</span></code></a> for a particular instance, the
operation will be silently skipped.  By default, an error is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>an error is raised by default if the callable
being used for the dictionary key returns
<a class="reference internal" href="internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE" title="sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoaderCallableStatus.NO_VALUE</span></code></a>, which in an ORM attribute
context indicates an attribute that was never populated with any value.
The <a class="reference internal" href="#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute" title="sqlalchemy.orm.mapped_collection"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_collection.ignore_unpopulated_attribute</span></code></a>
parameter may be set which will instead indicate that this condition
should be ignored, and the append operation silently skipped. This is
in contrast to the behavior of the 1.x series which would erroneously
populate the value in the dictionary with an arbitrary key value of
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">KeyFuncDict</span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict" title="Link to this definition">¶</a></dt>
<dd><p>Base for ORM mapped dictionary classes.</p>
<p>Extends the <code class="docutils literal notranslate"><span class="pre">dict</span></code> type with additional methods needed by SQLAlchemy ORM
collection classes. Use of <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> is most directly
by using the <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> or
<a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a> class factories.
<a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> may also serve as the base for user-defined
custom dictionary classes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedCollection</span></code> to
<a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a></p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a></p>
<p><a class="reference internal" href="#orm-custom-collection"><span class="std std-ref">Custom Collection Implementations</span></a></p>
</div>
<div class="class-members docutils container">
<p><strong>Members</strong></p>
<p><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.__init__"><span class="sig-name descname">__init__()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.clear"><span class="sig-name descname">clear()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.pop"><span class="sig-name descname">pop()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.popitem"><span class="sig-name descname">popitem()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.remove"><span class="sig-name descname">remove()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.set"><span class="sig-name descname">set()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.setdefault"><span class="sig-name descname">setdefault()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict.update"><span class="sig-name descname">update()</span></a></p>
</div>
<div class="class-bases docutils container">
<p><strong>Class signature</strong></p>
<p>class <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict</span></code></a> (<code class="docutils literal notranslate"><span class="pre">builtins.dict</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code>)</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.__init__">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keyfunc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dict_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_unpopulated_attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Create a new collection with keying provided by keyfunc.</p>
<p>keyfunc may be any callable that takes an object and returns an object
for use as a dictionary key.</p>
<p>The keyfunc will be called every time the ORM needs to add a member by
value-only (such as when loading instances from the database) or
remove a member.  The usual cautions about dictionary keying apply-
<code class="docutils literal notranslate"><span class="pre">keyfunc(object)</span></code> should return the same output for the life of the
collection.  Keying based on mutable properties can result in
unreachable instances “lost” in the collection.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.clear">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None.</span>&#160; <span class="pre">Remove</span> <span class="pre">all</span> <span class="pre">items</span> <span class="pre">from</span> <span class="pre">D.</span></span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.clear" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.pop">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">v,</span> <span class="pre">remove</span> <span class="pre">specified</span> <span class="pre">key</span> <span class="pre">and</span> <span class="pre">return</span> <span class="pre">the</span> <span class="pre">corresponding</span> <span class="pre">value.</span></span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.pop" title="Link to this definition">¶</a></dt>
<dd><p>If the key is not found, return the default if given; otherwise,
raise a KeyError.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.popitem">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">popitem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.popitem" title="Link to this definition">¶</a></dt>
<dd><p>Remove and return a (key, value) pair as a 2-tuple.</p>
<p>Pairs are returned in LIFO (last-in, first-out) order.
Raises KeyError if the dict is empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.remove">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_KT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_sa_initiator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="internals.html#sqlalchemy.orm.AttributeEventToken" title="sqlalchemy.orm.AttributeEventToken"><span class="pre">AttributeEventToken</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">False</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.remove" title="Link to this definition">¶</a></dt>
<dd><p>Remove an item by value, consulting the keyfunc for the key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.set">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_KT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_sa_initiator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="internals.html#sqlalchemy.orm.AttributeEventToken" title="sqlalchemy.orm.AttributeEventToken"><span class="pre">AttributeEventToken</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">False</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.set" title="Link to this definition">¶</a></dt>
<dd><p>Add an item by value, consulting the keyfunc for the key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.setdefault">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">setdefault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.setdefault" title="Link to this definition">¶</a></dt>
<dd><p>Insert key with a value of default if key is not in the dictionary.</p>
<p>Return the value for key if key is in the dictionary, else default.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.KeyFuncDict.update">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.KeyFuncDict.</span></code></a><span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">**F</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None.</span>&#160; <span class="pre">Update</span> <span class="pre">D</span> <span class="pre">from</span> <span class="pre">dict/iterable</span> <span class="pre">E</span> <span class="pre">and</span> <span class="pre">F.</span></span></span><a class="headerlink" href="#sqlalchemy.orm.KeyFuncDict.update" title="Link to this definition">¶</a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlalchemy.orm.MappedCollection">
<span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.</span></span><span class="sig-name descname"><span class="pre">MappedCollection</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;class</span> <span class="pre">'sqlalchemy.orm.mapped_collection.KeyFuncDict'&gt;</span></em><a class="headerlink" href="#sqlalchemy.orm.MappedCollection" title="Link to this definition">¶</a></dt>
<dd><p>Base for ORM mapped dictionary classes.</p>
<p>Extends the <code class="docutils literal notranslate"><span class="pre">dict</span></code> type with additional methods needed by SQLAlchemy ORM
collection classes. Use of <a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> is most directly
by using the <a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a> or
<a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a> class factories.
<a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a> may also serve as the base for user-defined
custom dictionary classes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>Renamed <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedCollection</span></code> to
<a class="reference internal" href="#sqlalchemy.orm.KeyFuncDict" title="sqlalchemy.orm.KeyFuncDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyFuncDict</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.attribute_keyed_dict" title="sqlalchemy.orm.attribute_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">attribute_keyed_dict()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.column_keyed_dict" title="sqlalchemy.orm.column_keyed_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_keyed_dict()</span></code></a></p>
<p><a class="reference internal" href="#orm-dictionary-collection"><span class="std std-ref">Dictionary Collections</span></a></p>
<p><a class="reference internal" href="#orm-custom-collection"><span class="std std-ref">Custom Collection Implementations</span></a></p>
</div>
</dd></dl>

</section>
<section id="collection-internals">
<h2>Collection Internals<a class="headerlink" href="#collection-internals" title="Link to this heading">¶</a></h2>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Object Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.bulk_replace"><span class="sig-name descname">bulk_replace</span></a>(values, existing_adapter, new_adapter[, initiator])</p></td>
<td><p>Load a new collection, firing events based on prior like membership.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><span class="sig-name descname">collection</span></a></p></td>
<td><p>Decorators for entity collection classes.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.collection_adapter"><span class="sig-name descname">collection_adapter</span></a></p></td>
<td><p>attrgetter(attr, …) –&gt; attrgetter object</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.CollectionAdapter"><span class="sig-name descname">CollectionAdapter</span></a></p></td>
<td><p>Bridges between the ORM and arbitrary Python collections.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedDict"><span class="sig-name descname">InstrumentedDict</span></a></p></td>
<td><p>An instrumented version of the built-in dict.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedList"><span class="sig-name descname">InstrumentedList</span></a></p></td>
<td><p>An instrumented version of the built-in list.</p></td>
</tr>
<tr class="row-even"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedSet"><span class="sig-name descname">InstrumentedSet</span></a></p></td>
<td><p>An instrumented version of the built-in set.</p></td>
</tr>
<tr class="row-odd"><td class="autosummary-name"><p><a class="reference internal" href="#sqlalchemy.orm.collections.prepare_instrumentation"><span class="sig-name descname">prepare_instrumentation</span></a>(factory)</p></td>
<td><p>Prepare a callable for future use as a collection class factory.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.bulk_replace">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">bulk_replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">existing_adapter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_adapter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initiator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.bulk_replace" title="Link to this definition">¶</a></dt>
<dd><p>Load a new collection, firing events based on prior like membership.</p>
<p>Appends instances in <code class="docutils literal notranslate"><span class="pre">values</span></code> onto the <code class="docutils literal notranslate"><span class="pre">new_adapter</span></code>. Events will be
fired for any instance not present in the <code class="docutils literal notranslate"><span class="pre">existing_adapter</span></code>.  Any
instances in <code class="docutils literal notranslate"><span class="pre">existing_adapter</span></code> not present in <code class="docutils literal notranslate"><span class="pre">values</span></code> will have
remove events fired upon them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.orm.collections.bulk_replace.params.values"></span><strong>values</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.collections.bulk_replace.params.values">¶</a> – An iterable of collection member instances</p></li>
<li><p><span class="target" id="sqlalchemy.orm.collections.bulk_replace.params.existing_adapter"></span><strong>existing_adapter</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.collections.bulk_replace.params.existing_adapter">¶</a> – A <a class="reference internal" href="#sqlalchemy.orm.collections.CollectionAdapter" title="sqlalchemy.orm.collections.CollectionAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CollectionAdapter</span></code></a> of
instances to be replaced</p></li>
<li><p><span class="target" id="sqlalchemy.orm.collections.bulk_replace.params.new_adapter"></span><strong>new_adapter</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.collections.bulk_replace.params.new_adapter">¶</a> – An empty <a class="reference internal" href="#sqlalchemy.orm.collections.CollectionAdapter" title="sqlalchemy.orm.collections.CollectionAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CollectionAdapter</span></code></a>
to load with <code class="docutils literal notranslate"><span class="pre">values</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">collection</span></span><a class="headerlink" href="#sqlalchemy.orm.collections.collection" title="Link to this definition">¶</a></dt>
<dd><p>Decorators for entity collection classes.</p>
<p>The decorators fall into two groups: annotations and interception recipes.</p>
<p>The annotating decorators (appender, remover, iterator, converter,
internally_instrumented) indicate the method’s purpose and take no
arguments.  They are not written with parens:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">appender</span>
<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
<p>The recipe decorators all require parens, even those that take no
arguments:</p>
<div class="class-members docutils container">
<p><strong>Members</strong></p>
<p><a class="reference internal" href="#sqlalchemy.orm.collections.collection.adds"><span class="sig-name descname">adds()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.appender"><span class="sig-name descname">appender()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.converter"><span class="sig-name descname">converter()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.internally_instrumented"><span class="sig-name descname">internally_instrumented()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.iterator"><span class="sig-name descname">iterator()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.remover"><span class="sig-name descname">remover()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.removes"><span class="sig-name descname">removes()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.removes_return"><span class="sig-name descname">removes_return()</span></a>, <a class="reference internal" href="#sqlalchemy.orm.collections.collection.replaces"><span class="sig-name descname">replaces()</span></a></p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">adds</span><span class="p">(</span><span class="s1">&#39;entity&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span> <span class="o">...</span>

<span class="nd">@collection</span><span class="o">.</span><span class="n">removes_return</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.adds">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.adds" title="Link to this definition">¶</a></dt>
<dd><p>Mark the method as adding an entity to the collection.</p>
<p>Adds “add to collection” handling to the method.  The decorator
argument indicates which method argument holds the SQLAlchemy-relevant
value.  Arguments can be specified positionally (i.e. integer) or by
name:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">adds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="o">...</span>

<span class="nd">@collection</span><span class="o">.</span><span class="n">adds</span><span class="p">(</span><span class="s1">&#39;entity&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thing</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.appender">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">appender</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.appender" title="Link to this definition">¶</a></dt>
<dd><p>Tag the method as the collection appender.</p>
<p>The appender method is called with one positional argument: the value
to append. The method will be automatically decorated with ‘adds(1)’
if not already decorated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">appender</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># or, equivalently</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">appender</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">adds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># for mapping type, an &#39;append&#39; may kick out a previous value</span>
<span class="c1"># that occupies that slot.  consider d[&#39;a&#39;] = &#39;foo&#39;- any previous</span>
<span class="c1"># value in d[&#39;a&#39;] is discarded.</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">appender</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">replaces</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">some_key_func</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">entity</span>
    <span class="k">return</span> <span class="n">previous</span></pre></div>
</div>
<p>If the value to append is not allowed in the collection, you may
raise an exception.  Something to remember is that the appender
will be called for each object mapped by a database query.  If the
database contains rows that violate your collection semantics, you
will need to get creative to fix the problem, as access via the
collection will not work.</p>
<p>If the appender method is internally instrumented, you must also
receive the keyword argument ‘_sa_initiator’ and ensure its
promulgation to collection events.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.converter">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">converter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.converter" title="Link to this definition">¶</a></dt>
<dd><p>Tag the method as the collection converter.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.3: </span>The <a class="reference internal" href="#sqlalchemy.orm.collections.collection.converter" title="sqlalchemy.orm.collections.collection.converter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collection.converter()</span></code></a> handler is deprecated and will be removed in a future release.  Please refer to the <code class="xref py py-class docutils literal notranslate"><span class="pre">bulk_replace</span></code> listener interface in conjunction with the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> function.</p>
</div>
<p>This optional method will be called when a collection is being
replaced entirely, as in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">myobj</span><span class="o">.</span><span class="n">acollection</span> <span class="o">=</span> <span class="p">[</span><span class="n">newvalue1</span><span class="p">,</span> <span class="n">newvalue2</span><span class="p">]</span></pre></div>
</div>
<p>The converter method will receive the object being assigned and should
return an iterable of values suitable for use by the <code class="docutils literal notranslate"><span class="pre">appender</span></code>
method.  A converter must not assign values or mutate the collection,
its sole job is to adapt the value the user provides into an iterable
of values for the ORM’s use.</p>
<p>The default converter implementation will use duck-typing to do the
conversion.  A dict-like collection will be convert into an iterable
of dictionary values, and other types will simply be iterated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">converter</span>
<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
<p>If the duck-typing of the object does not match the type of this
collection, a TypeError is raised.</p>
<p>Supply an implementation of this method if you want to expand the
range of possible types that can be assigned in bulk or perform
validation on the values about to be assigned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.internally_instrumented">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">internally_instrumented</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.internally_instrumented" title="Link to this definition">¶</a></dt>
<dd><p>Tag the method as instrumented.</p>
<p>This tag will prevent any decoration from being applied to the
method. Use this if you are orchestrating your own calls to
<code class="xref py py-func docutils literal notranslate"><span class="pre">collection_adapter()</span></code> in one of the basic SQLAlchemy
interface methods, or to prevent an automatic ABC method
decoration from wrapping your implementation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># normally an &#39;extend&#39; method on a list-like class would be</span>
<span class="c1"># automatically intercepted and re-implemented in terms of</span>
<span class="c1"># SQLAlchemy events and append().  your implementation will</span>
<span class="c1"># never be called, unless:</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">internally_instrumented</span>
<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.iterator">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.iterator" title="Link to this definition">¶</a></dt>
<dd><p>Tag the method as the collection remover.</p>
<p>The iterator method is called with no arguments.  It is expected to
return an iterator over all collection members:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">iterator</span>
<span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.remover">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">remover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.remover" title="Link to this definition">¶</a></dt>
<dd><p>Tag the method as the collection remover.</p>
<p>The remover method is called with one positional argument: the value
to remove. The method will be automatically decorated with
<a class="reference internal" href="#sqlalchemy.orm.collections.collection.removes_return" title="sqlalchemy.orm.collections.collection.removes_return"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removes_return()</span></code></a> if not already decorated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">remover</span>
<span class="k">def</span> <span class="nf">zap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># or, equivalently</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">remover</span>
<span class="nd">@collection</span><span class="o">.</span><span class="n">removes_return</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">zap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">):</span> <span class="o">...</span></pre></div>
</div>
<p>If the value to remove is not present in the collection, you may
raise an exception or return None to ignore the error.</p>
<p>If the remove method is internally instrumented, you must also
receive the keyword argument ‘_sa_initiator’ and ensure its
promulgation to collection events.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.removes">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">removes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.removes" title="Link to this definition">¶</a></dt>
<dd><p>Mark the method as removing an entity in the collection.</p>
<p>Adds “remove from collection” handling to the method.  The decorator
argument indicates which method argument holds the SQLAlchemy-relevant
value to be removed. Arguments can be specified positionally (i.e.
integer) or by name:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">removes</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
<p>For methods where the value to remove is not known at call-time, use
collection.removes_return.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.removes_return">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">removes_return</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.removes_return" title="Link to this definition">¶</a></dt>
<dd><p>Mark the method as removing an entity in the collection.</p>
<p>Adds “remove from collection” handling to the method.  The return
value of the method, if any, is considered the value to remove.  The
method arguments are not inspected:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">removes_return</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
<p>For methods where the value to remove is known at call-time, use
collection.remove.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection.replaces">
<em class="property"><span class="pre">method</span> </em><a class="reference internal" href="#sqlalchemy.orm.collections.collection"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.collection.</span></code></a><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">replaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.collections.collection.replaces" title="Link to this definition">¶</a></dt>
<dd><p>Mark the method as replacing an entity in the collection.</p>
<p>Adds “add to collection” and “remove from collection” handling to
the method.  The decorator argument indicates which method argument
holds the SQLAlchemy-relevant value to be added, and return value, if
any will be considered the value to remove.</p>
<p>Arguments can be specified positionally (i.e. integer) or by name:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@collection</span><span class="o">.</span><span class="n">replaces</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="o">...</span></pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.collection_adapter">
<span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">collection_adapter</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">operator.attrgetter('_sa_adapter')</span></em><a class="headerlink" href="#sqlalchemy.orm.collections.collection_adapter" title="Link to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.CollectionAdapter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">CollectionAdapter</span></span><a class="headerlink" href="#sqlalchemy.orm.collections.CollectionAdapter" title="Link to this definition">¶</a></dt>
<dd><p>Bridges between the ORM and arbitrary Python collections.</p>
<p>Proxies base-level collection operations (append, remove, iterate)
to the underlying Python collection, and emits add/remove events for
entities entering or leaving the collection.</p>
<p>The ORM uses <a class="reference internal" href="#sqlalchemy.orm.collections.CollectionAdapter" title="sqlalchemy.orm.collections.CollectionAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CollectionAdapter</span></code></a> exclusively for interaction with
entity collections.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.InstrumentedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">InstrumentedDict</span></span><a class="headerlink" href="#sqlalchemy.orm.collections.InstrumentedDict" title="Link to this definition">¶</a></dt>
<dd><p>An instrumented version of the built-in dict.</p>
<div class="class-bases docutils container">
<p><strong>Class signature</strong></p>
<p>class <a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedDict" title="sqlalchemy.orm.collections.InstrumentedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.InstrumentedDict</span></code></a> (<code class="docutils literal notranslate"><span class="pre">builtins.dict</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code>)</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.InstrumentedList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">InstrumentedList</span></span><a class="headerlink" href="#sqlalchemy.orm.collections.InstrumentedList" title="Link to this definition">¶</a></dt>
<dd><p>An instrumented version of the built-in list.</p>
<div class="class-bases docutils container">
<p><strong>Class signature</strong></p>
<p>class <a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedList" title="sqlalchemy.orm.collections.InstrumentedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.InstrumentedList</span></code></a> (<code class="docutils literal notranslate"><span class="pre">builtins.list</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code>)</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.InstrumentedSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">InstrumentedSet</span></span><a class="headerlink" href="#sqlalchemy.orm.collections.InstrumentedSet" title="Link to this definition">¶</a></dt>
<dd><p>An instrumented version of the built-in set.</p>
<div class="class-bases docutils container">
<p><strong>Class signature</strong></p>
<p>class <a class="reference internal" href="#sqlalchemy.orm.collections.InstrumentedSet" title="sqlalchemy.orm.collections.InstrumentedSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.collections.InstrumentedSet</span></code></a> (<code class="docutils literal notranslate"><span class="pre">builtins.set</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code>)</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlalchemy.orm.collections.prepare_instrumentation">
<em class="property"><span class="pre">function</span> </em><span class="sig-prename descclassname"><span class="pre">sqlalchemy.orm.collections.</span></span><span class="sig-name descname"><span class="pre">prepare_instrumentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Type</span><span class="p"><span class="pre">[</span></span><span class="pre">Collection</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">_AdaptedCollectionProtocol</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">_AdaptedCollectionProtocol</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#sqlalchemy.orm.collections.prepare_instrumentation" title="Link to this definition">¶</a></dt>
<dd><p>Prepare a callable for future use as a collection class factory.</p>
<p>Given a collection class factory (either a type or no-arg callable),
return another factory that will produce compatible instances when
called.</p>
<p>This function is responsible for converting collection_class=list
into the run-time behavior of collection_class=InstrumentedList.</p>
</dd></dl>

</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="large_collections.html" title="previous chapter">Working with Large Collections</a>
        Next:
        <a href="relationship_persistence.html" title="next chapter">Special Relationship Persistence Patterns</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2024, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.2.6.

    Documentation last generated: Mon Aug  5 19:31:00 2024 JST

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      document.documentElement.dataset.content_root = '../';

    </script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



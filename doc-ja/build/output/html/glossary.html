<!DOCTYPE html>



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    Glossary
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/default.css" type="text/css" />
                <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
        <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="index.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.31</span>


        | Release Date: June 18, 2024

    </div>

    <h1><a href="index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy 2.0 Documentation">SQLAlchemy 2.0 Documentation</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="intro.html">Overview</a></span></li>
<li><span class="link-container"><a class="reference external" href="tutorial/index.html">SQLAlchemy Unified Tutorial</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm/index.html">SQLAlchemy ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="core/index.html">SQLAlchemy Core</a></span></li>
<li><span class="link-container"><a class="reference external" href="dialects/index.html">Dialects</a></span></li>
<li><span class="link-container"><a class="reference external" href="faq/index.html">Frequently Asked Questions</a></span></li>
<li><span class="link-container"><a class="reference external" href="errors.html">Error Messages</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog/index.html">Changes and Migration</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>

            <li><b>Up:</b> <a href="index.html">Home</a></li>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar glossary" >
        
<section id="glossary">
<span id="id1"></span><h1>Glossary<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h1>
<dl class="glossary">
<dt id="term-1.x-style">1.x style<a class="headerlink" href="#term-1.x-style" title="Link to this term">¶</a></dt><dt id="term-2.0-style">2.0 style<a class="headerlink" href="#term-2.0-style" title="Link to this term">¶</a></dt><dt id="term-0">1.x-style<a class="headerlink" href="#term-0" title="Link to this term">¶</a></dt><dt id="term-1">2.0-style<a class="headerlink" href="#term-1" title="Link to this term">¶</a></dt><dd><p>これらの用語はSQLAlchemy 1.4で新しく追加されたもので、 <a class="reference internal" href="changelog/migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - Major Migration Guide</span></a> で説明されているSQLAlchemy 1.4 -&gt; 2.0の移行計画を参照しています。”1.x style”という用語は、SQLAlchemyの1.xシリーズおよびそれ以前(例えば1.3、1.2など)で文書化されている方法で使用されるAPIを指し、”2.0 style”という用語は、バージョン2.0でのAPIの表示方法を指します。バージョン1.4は2.0のAPIのほぼすべてをいわゆる”移行モード”で実装していますが、バージョン2.0はレガシーコードが2.0との互換性を維持できるようにレガシーの <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> オブジェクトを維持しています。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="changelog/migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - Major Migration Guide</span></a></p>
</div>
</dd>
<dt id="term-ACID">ACID<a class="headerlink" href="#term-ACID" title="Link to this term">¶</a></dt><dt id="term-ACID-model">ACID model<a class="headerlink" href="#term-ACID-model" title="Link to this term">¶</a></dt><dd><p>“Atomicity, Consistency, Isolation, Durability”の頭字語。データベーストランザクションが確実に処理されることを保証するプロパティのセットです。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-atomicity"><span class="xref std std-term">atomicity</span></a></p>
<p><a class="reference internal" href="#term-consistency"><span class="xref std std-term">consistency</span></a></p>
<p><a class="reference internal" href="#term-isolation"><span class="xref std std-term">isolation</span></a></p>
<p><a class="reference internal" href="#term-durability"><span class="xref std std-term">durability</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/ACID_Model">ACID Model (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-association-relationship">association relationship<a class="headerlink" href="#term-association-relationship" title="Link to this term">¶</a></dt><dd><p>2層の <a class="reference internal" href="#term-relationship"><span class="xref std std-term">relationship</span></a> で、中間に関連付けテーブルを使って2つのテーブルをリンクします。関連付け関係は <a class="reference internal" href="#term-many-to-many"><span class="xref std std-term">many to many</span></a> 関係とは異なり、多対多テーブルは完全なクラスによってマップされます。多対多の場合のように <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqlalchemy.orm.relationship()</span></code></a> 構文によって見えないように処理されるのではなく、追加の属性が明示的に利用できるようになります。</p>
<p>たとえば、従業員をプロジェクトに関連付け、その従業員の特定のロールもプロジェクトに格納する場合、リレーショナルスキーマは次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee_project</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">employee_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">project_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">role_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">employee_id</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">employee</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">project_id</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">project</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記のSQLAlchemy宣言マッピングは、次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Project</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;project&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">EmployeeProject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee_project&quot;</span>

    <span class="n">employee_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;employee.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">project_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;project.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">role_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">project</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;project_employees&quot;</span><span class="p">)</span>
    <span class="n">employee</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;employee_projects&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>ロール名を指定して、従業員をプロジェクトに追加できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj</span> <span class="o">=</span> <span class="n">Project</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Client A&quot;</span><span class="p">)</span>

<span class="n">emp1</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;emp1&quot;</span><span class="p">)</span>
<span class="n">emp2</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;emp2&quot;</span><span class="p">)</span>

<span class="n">proj</span><span class="o">.</span><span class="n">project_employees</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">EmployeeProject</span><span class="p">(</span><span class="n">employee</span><span class="o">=</span><span class="n">emp1</span><span class="p">,</span> <span class="n">role_name</span><span class="o">=</span><span class="s2">&quot;tech lead&quot;</span><span class="p">),</span>
        <span class="n">EmployeeProject</span><span class="p">(</span><span class="n">employee</span><span class="o">=</span><span class="n">emp2</span><span class="p">,</span> <span class="n">role_name</span><span class="o">=</span><span class="s2">&quot;account executive&quot;</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-many-to-many"><span class="xref std std-term">many to many</span></a></p>
</div>
</dd>
<dt id="term-atomicity">atomicity<a class="headerlink" href="#term-atomicity" title="Link to this term">¶</a></dt><dd><p>原子性は <a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a> モデルの構成要素の1つであり、各トランザクションが”all or nothing”であることを要求します。つまり、トランザクションの一部が失敗した場合、トランザクション全体が失敗し、データベースの状態は変更されないままになります。原子性システムは、電源障害、エラー、クラッシュなど、あらゆる状況で原子性を保証する必要があります。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">Atomicity (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-attached">attached<a class="headerlink" href="#term-attached" title="Link to this term">¶</a></dt><dd><p>現在特定のに関連付けられているORMオブジェクトを示します。</p>
<p><a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a></p>
</div>
</dd>
<dt id="term-backref">backref<a class="headerlink" href="#term-backref" title="Link to this term">¶</a></dt><dt id="term-bidirectional-relationship">bidirectional relationship<a class="headerlink" href="#term-bidirectional-relationship" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-relationship"><span class="xref std std-term">relationship</span></a> システムを拡張したもので、2つの異なる <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> オブジェクトを相互に関連付けることができます。これにより、どちらかの側で変更が発生したときにメモリ内で調整されます。これら2つの関係を構築する最も一般的な方法は、一方の側に対して <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 関数を明示的に使用し、もう一方の:func:<cite>~sqlalchemy.orm.relationship</cite> が自動的に作成されるように、それに対して`backref`キーワードを指定することです。これを <a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a> で使用した例に対して次のように説明できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Department</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;department&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;department&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">dep_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;department.id&quot;</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>backrefは、1対多、多対1、 <a class="reference internal" href="#term-many-to-many"><span class="xref std std-term">many to many</span></a> など、任意の関係に適用できます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-relationship"><span class="xref std std-term">relationship</span></a></p>
<p><a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a></p>
<p><a class="reference internal" href="#term-many-to-one"><span class="xref std std-term">many to one</span></a></p>
<p><a class="reference internal" href="#term-many-to-many"><span class="xref std std-term">many to many</span></a></p>
</div>
</dd>
<dt id="term-bound-parameter">bound parameter<a class="headerlink" href="#term-bound-parameter" title="Link to this term">¶</a></dt><dt id="term-bound-parameters">bound parameters<a class="headerlink" href="#term-bound-parameters" title="Link to this term">¶</a></dt><dt id="term-bind-parameter">bind parameter<a class="headerlink" href="#term-bind-parameter" title="Link to this term">¶</a></dt><dt id="term-bind-parameters">bind parameters<a class="headerlink" href="#term-bind-parameters" title="Link to this term">¶</a></dt><dd><p>バウンドパラメータは、データが <a class="reference internal" href="#term-DBAPI"><span class="xref std std-term">DBAPI</span></a> データベースドライバに渡される主要な手段です。呼び出される操作はSQL文の文字列に基づいていますが、データ値自体は別々に渡されます。ドライバには、これらの文字列を安全に処理してバックエンドのデータベースサーバに渡すロジックが含まれています。これには、パラメータをSQL文字列自体にフォーマットするか、別のプロトコルを使用してデータベースに渡す必要があります。</p>
<p>データベースドライバがこれを行う特定のシステムは、呼び出し元には関係ありません。重要なのは、外部では、データはSQL文字列自体の一部としてではなく、 <strong>常に</strong> 別々に渡されるべきであるということです。これは、SQLインジェクションに対して適切なセキュリティを確保するためにも、ドライバが最高のパフォーマンスを発揮できるようにするためにも不可欠です。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Prepared_statement">Prepared Statement</a> - Wikipediaより</p>
<p><a class="reference external" href="https://use-the-index-luke.com/sql/where-clause/bind-parameters">bind parameters</a> - at Use The Index, Luke!</p>
<p><a class="reference internal" href="tutorial/dbapi_transactions.html#tutorial-sending-parameters"><span class="std std-ref">Sending Parameters</span></a> - <a class="reference internal" href="tutorial/index.html#unified-tutorial"><span class="std std-ref">SQLAlchemy Unified Tutorial</span></a></p>
</div>
</dd>
<dt id="term-candidate-key">candidate key<a class="headerlink" href="#term-candidate-key" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-relational-algebra"><span class="xref std std-term">relational algebra</span></a> 用語で、一意に識別されるキーを形成するアトリビュートまたはアトリビュートのセットを指します。1つのローは複数の候補キーを持つことができ、それぞれがそのローのプライマリ・キーとして使用されます。テーブルのプライマリ・キーは常に候補キーです。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Candidate_key">Candidate key (Wkipediaより)</a></p>
<p><a class="reference external" href="https://www.databasestar.com/database-keys/">https://www.databasestar.com/database-keys/</a></p>
</div>
</dd>
<dt id="term-cartesian-product">cartesian product<a class="headerlink" href="#term-cartesian-product" title="Link to this term">¶</a></dt><dd><p>2つの集合AとBが与えられた場合、直積はすべての順序付けられた対(a, b)の集合であり、aはAにあり、bはBにあります。</p>
<p>SQLデータベースに関して言えば、直積は、2つ以上のテーブル(またはその他のサブクエリ)から、あるテーブルのローと別のテーブルのローとの間に(直接的または間接的に)何の種類の基準も確立せずに選択する場合に発生します。テーブルAとテーブルBから同時にSELECTを実行すると、AのすべてのローがBの最初のローに一致し、AのすべてのローがBの2番目のローに一致し、AのすべてのローがBのすべてのローとペアになるまで続きます。</p>
<p>デカルト積は膨大な結果セットを生成し、防止しなければクライアント・アプリケーションを簡単にクラッシュさせる可能性があります。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian Product (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-cascade">cascade<a class="headerlink" href="#term-cascade" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyで使用される用語で、特定のオブジェクトに対して行われるORMパーシステンスアクションが、そのオブジェクトに直接関連付けられた他のオブジェクトにどのように拡張されるかを記述します。SQLAlchemyでは、これらのオブジェクトの関連付けは <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 構文を使用して設定されます。 <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> には <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade</span></code></a> というパラメータが含まれていて、特定のパーシステンス操作がどのようにカスケードされるかについてのオプションを提供します。</p>
<p>SQLAlchemyにおけるこのシステムの一般的なアーキテクチャと同様に、”カスケード”という用語は、良くも悪くも、Hibernate ORMから借りました。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/cascades.html#unitofwork-cascades"><span class="std std-ref">Cascades</span></a></p>
</div>
</dd>
<dt id="term-check-constraint">check constraint<a class="headerlink" href="#term-check-constraint" title="Link to this term">¶</a></dt><dd><p>チェック制約は、リレーショナル・データベースのテーブル内のエントリを追加または更新するときに有効なデータを定義する条件です。チェック制約はテーブル内の各行に適用されます。(Wikipediaより)</p>
<p>A check constraint can be added to a table in standard SQL using <a class="reference internal" href="#term-DDL"><span class="xref std std-term">DDL</span></a> like the following:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">distributors</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">zipchk</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="k">char_length</span><span class="p">(</span><span class="n">zipcode</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Check_constraint">CHECK constraint (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-columns-clause">columns clause<a class="headerlink" href="#term-columns-clause" title="Link to this term">¶</a></dt><dd><p>結果セットに返されるSQL式を列挙する <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 文の部分です。式は <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> キーワードの直後に続き、カンマで区切られた個々の式のリストです。</p>
<p>例:
.. sourcecode:: sql</p>
<blockquote>
<div><p>SELECT user_account.name, user_account.email
FROM user_account WHERE user_account.name = ‘fred’</p>
</div></blockquote>
<p>上記の <code class="docutils literal notranslate"><span class="pre">user_acount.name</span></code> 、 <code class="docutils literal notranslate"><span class="pre">user_account.email</span></code> 列のリストは、 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> の <code class="docutils literal notranslate"><span class="pre">columns</span></code> 節です。</p>
</dd>
<dt id="term-composite-primary-key">composite primary key<a class="headerlink" href="#term-composite-primary-key" title="Link to this term">¶</a></dt><dd><p>複数の列を持つ <a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a> 。特定のデータベース行は、単一の値ではなく、複数の列に基づいて一意です。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a></p>
</div>
</dd>
<dt id="term-consistency">consistency<a class="headerlink" href="#term-consistency" title="Link to this term">¶</a></dt><dd><p>一貫性は <a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a> モデルの構成要素の1つであり、任意のトランザクションがデータベースをある有効な状態から別の有効な状態にすることを保証します。データベースに書き込まれるデータはすべて、定義されたすべてのルールに従って有効でなければなりません。これには <a class="reference internal" href="#term-constraints"><span class="xref std std-term">constraints</span></a> 、cascade、triggers、およびそれらの任意の組み合わせが含まれますが、これらに限定されません。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Consistency_(database_systems)">Consistency (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-constraint">constraint<a class="headerlink" href="#term-constraint" title="Link to this term">¶</a></dt><dt id="term-constraints">constraints<a class="headerlink" href="#term-constraints" title="Link to this term">¶</a></dt><dt id="term-constrained">constrained<a class="headerlink" href="#term-constrained" title="Link to this term">¶</a></dt><dd><p>データの有効性と一貫性を保証する、リレーショナルデータベース内で確立された規則。制約の一般的な形式には、<a class="reference internal" href="#term-primary-key-constraint"><span class="xref std std-term">primary key constraint</span></a> 、 <a class="reference internal" href="#term-foreign-key-constraint"><span class="xref std std-term">foreign key constraint</span></a> 、および <a class="reference internal" href="#term-check-constraint"><span class="xref std std-term">check constraint</span></a> があります。</p>
</dd>
<dt id="term-correlates">correlates<a class="headerlink" href="#term-correlates" title="Link to this term">¶</a></dt><dt id="term-correlated-subquery">correlated subquery<a class="headerlink" href="#term-correlated-subquery" title="Link to this term">¶</a></dt><dt id="term-correlated-subqueries">correlated subqueries<a class="headerlink" href="#term-correlated-subqueries" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-subquery"><span class="xref std std-term">subquery</span></a> は、それを囲む <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 内のデータに依存する場合に相関があります。</p>
<p>以下では、サブクエリが <code class="docutils literal notranslate"><span class="pre">email_address</span></code> テーブルから集約値 <code class="docutils literal notranslate"><span class="pre">MIN(a.id)</span></code> を選択し、 <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> の各値に対して呼び出され、この列の値を <code class="docutils literal notranslate"><span class="pre">email_address.user_account_id</span></code> 列に関連付けます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">email_address</span><span class="p">.</span><span class="n">email</span>
<span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">email_address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">email_address</span><span class="p">.</span><span class="n">user_account_id</span>
<span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">email_address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="k">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">user_account_id</span><span class="o">=</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
<span class="w"> </span><span class="p">)</span></pre></div>
</div>
<p>上記のサブクエリは、このネストされたクエリの <code class="docutils literal notranslate"><span class="pre">FROM</span></code> 節にはない <code class="docutils literal notranslate"><span class="pre">user_account</span></code> テーブルを参照しています。代わりに、 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> テーブルは、それを囲むクエリから受信されます。 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> から選択された各行は、サブクエリの明確な実行につながります。</p>
<p>ほとんどの場合、相関サブクエリは、ORDER BY句やHAVING句だけでなく、すぐ外側の <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 文の <a class="reference internal" href="#term-WHERE-clause"><span class="xref std std-term">WHERE clause</span></a> や <a class="reference internal" href="#term-columns-clause"><span class="xref std std-term">columns clause</span></a> にも存在します。</p>
<p>あまり一般的ではありませんが、相関する副問い合わせが、囲んでいる <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> の <a class="reference internal" href="#term-FROM-clause"><span class="xref std std-term">FROM clause</span></a> に存在することがあります。このような場合、相関は通常、囲んでいる <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 自体が、次のような別の <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> のWHERE、ORDER BY、カラム、またはHAVING句で囲まれていることに起因します。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">parent</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">parent</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="k">SELECT</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">parent_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">parent_id</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pos</span>
<span class="w">        </span><span class="k">FROM</span><span class="w"> </span><span class="n">child</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">parent_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">pos</span>
<span class="w">    </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span></pre></div>
</div>
<p>Correlation from one <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> directly to one which encloses the correlated query via its <code class="docutils literal notranslate"><span class="pre">FROM</span></code> clause is not possible, because the correlation can only proceed once the original source rows from the enclosing statement’s FROM clause are available.</p>
<p>1つの <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> から、その <code class="docutils literal notranslate"><span class="pre">FROM</span></code> 節を介して相関された問い合わせを囲む直接の相関は不可能です。なぜなら、相関は、囲んでいる文のFROM節から元のソース行が利用可能になって初めて実行されるからです。</p>
</dd>
<dt id="term-crud">crud<a class="headerlink" href="#term-crud" title="Link to this term">¶</a></dt><dt id="term-CRUD">CRUD<a class="headerlink" href="#term-CRUD" title="Link to this term">¶</a></dt><dd><p>“Create, Update, Delete”を意味する頭字語。SQLにおけるこの用語は、データベースからデータを作成、変更、削除する操作の集合を指し、 <a class="reference internal" href="#term-DML"><span class="xref std std-term">DML</span></a> としても知られています。また、一般的には、 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 、<code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> 、 <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> 文を指します。</p>
</dd>
<dt id="term-cursor">cursor<a class="headerlink" href="#term-cursor" title="Link to this term">¶</a></dt><dd><p>データベース内のレコードの走査を可能にする制御構造です。Python DBAPIでは、カーソル・オブジェクトは実際に文の実行の開始点であり、結果のフェッチに使用されるインタフェースでもあります。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0249/#cursor-objects">Cursor Objects (in pep-249)</a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Cursor_(databases)">Cursor (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-cyclomatic-complexity">cyclomatic complexity<a class="headerlink" href="#term-cyclomatic-complexity" title="Link to this term">¶</a></dt><dd><p>プログラムのソースコード内の可能なパスの数に基づくコードの複雑さの尺度。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity</a></p>
</div>
</dd>
<dt id="term-DBAPI">DBAPI<a class="headerlink" href="#term-DBAPI" title="Link to this term">¶</a></dt><dt id="term-pep-249">pep-249<a class="headerlink" href="#term-pep-249" title="Link to this term">¶</a></dt><dd><p>DBAPIは”Python Database API Specification”の省略形です。これは、すべてのデータベース接続パッケージに共通の使用パターンを定義するために、Python内で広く使用されている仕様です。DBAPIは”低レベル”のAPIで、通常はPythonアプリケーションでデータベースと通信するために使用される最低レベルのシステムです。SQLAlchemyの <a class="reference internal" href="#term-dialect"><span class="xref std std-term">dialect</span></a> システムはDBAPIの操作を中心に構築されており、特定のデータベースエンジン上で特定のDBAPIを提供する個々のダイアレクトクラスを提供します。たとえば、 <a class="reference internal" href="core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> のURL <code class="docutils literal notranslate"><span class="pre">postgresql+psycopg2://&#64;localhost/test</span></code> は <a class="reference internal" href="dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2" title="sqlalchemy.dialects.postgresql.psycopg2"><code class="xref py py-mod docutils literal notranslate"><span class="pre">psycopg2</span></code></a> DBAPI/ダイアレクトの組み合わせを参照し、URL <code class="docutils literal notranslate"><span class="pre">MySQL+mysqldb://&#64;localhost/test</span></code> は <code class="xref py py-mod docutils literal notranslate"><span class="pre">MySQL</span> <span class="pre">for</span> <span class="pre">Python</span></code> DBAPI/ダイアレクトの組み合わせを参照します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">PEP 249 - Python Database API Specification v2.0</a></p>
</div>
</dd>
<dt id="term-DDL">DDL<a class="headerlink" href="#term-DDL" title="Link to this term">¶</a></dt><dd><p><strong>Data Definition Language</strong> の頭字語です。DDLは、リレーショナル・データベースがデータベース・スキーマ内の表、制約およびその他の永続オブジェクトを構成するために使用するSQLのサブセットです。SQLAlchemyは、DDL式を構築および出力するための豊富なAPIを提供します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/metadata.html"><span class="std std-ref">Describing Databases with MetaData</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Data_definition_language">DDL (Wkipediaより)</a></p>
<p><a class="reference internal" href="#term-DML"><span class="xref std std-term">DML</span></a></p>
<p><a class="reference internal" href="#term-DQL"><span class="xref std std-term">DQL</span></a></p>
</div>
</dd>
<dt id="term-deleted">deleted<a class="headerlink" href="#term-deleted" title="Link to this term">¶</a></dt><dd><p>これは、オブジェクトが <a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a> 内で持つことができる主要なオブジェクト状態の1つを記述します。削除されたオブジェクトとは、以前は永続的であったオブジェクトで、その行を削除するためにフラッシュ内でデータベースにDELETE文が発行されました。セッションのトランザクションがコミットされると、オブジェクトは <a class="reference internal" href="#term-detached"><span class="xref std std-term">detached</span></a> 状態に移動します。あるいは、セッションのトランザクションがロールバックされると、DELETEは元に戻され、オブジェクトは <a class="reference internal" href="#term-persistent"><span class="xref std std-term">persistent</span></a> 状態に戻ります。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a></p>
</div>
</dd>
<dt id="term-descriptor">descriptor<a class="headerlink" href="#term-descriptor" title="Link to this term">¶</a></dt><dt id="term-descriptors">descriptors<a class="headerlink" href="#term-descriptors" title="Link to this term">¶</a></dt><dd><p>Pythonでは、記述子は”バインド動作”を持つオブジェクト属性であり、その属性アクセスは <a class="reference external" href="https://docs.python.org/howto/descriptor.html">descriptor protocol</a>.  のメソッドによってオーバーライドされています。これらのメソッドは、 <code class="docutils literal notranslate"><span class="pre">__get__()</span></code> 、<code class="docutils literal notranslate"><span class="pre">__set__()</span></code> 、および <code class="docutils literal notranslate"><span class="pre">__delete__()</span></code> です。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、それは記述子であると言われます。</p>
<p>SQLAlchemyでは、記述子は、マップされたクラスに対して属性の動作を提供するために頻繁に使用されます。クラスが次のようにマップされる場合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>定義が完了すると、 <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> クラスは <a class="reference internal" href="#term-mapped"><span class="xref std std-term">mapped</span></a> になります。その時点で、 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> オブジェクトから始まる <code class="docutils literal notranslate"><span class="pre">id</span></code> 属性と <code class="docutils literal notranslate"><span class="pre">data</span></code> 属性は、 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a> のインスタンスを持つ <a class="reference internal" href="#term-instrumentation"><span class="xref std std-term">instrumentation</span></a> システムに置き換えられます。これは、前述の <code class="docutils literal notranslate"><span class="pre">__get__()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">__set__()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">__delete__()</span></code> メソッドを提供する記述子です。 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a> をクラスレベルで使用すると、SQL式が生成されます:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">data_1</span>
</div></pre></div>
</div>
<p>インスタンスレベルでは値の変更を追跡し、<a class="reference internal" href="#term-lazy-loads"><span class="xref std std-term">lazy loads</span></a> はデータベースからアンロードされた属性も追跡します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;some data&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">added</span>
<span class="go">&quot;some data&quot;</span></pre></div>
</div>
</dd>
<dt id="term-detached">detached<a class="headerlink" href="#term-detached" title="Link to this term">¶</a></dt><dd><p>これは、オブジェクトが <a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a> 内で持つことができる主要なオブジェクト状態の1つを記述します。デタッチされたオブジェクトとは、データベースID(すなわち主キー)を持つが、どのセッションにも関連付けられていないオブジェクトです。以前 <a class="reference internal" href="#term-persistent"><span class="xref std std-term">persistent</span></a> であったオブジェクトが、削除されたか、所有しているセッションが閉じられたためにセッションから削除された場合、デタッチ状態に移行します。デタッチ状態は一般に、オブジェクトがセッション間で移動されるとき、または外部オブジェクトキャッシュとの間で移動されるときに使用されます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a></p>
</div>
</dd>
<dt id="term-dialect">dialect<a class="headerlink" href="#term-dialect" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyでは、”ダイアレクト”は、特定の種類のデータベースバックエンドと、そのデータベースの特定の種類のPythonドライバ(または <a class="reference internal" href="#term-DBAPI"><span class="xref std std-term">DBAPI</span></a> )でデータベース操作を進めるための情報とメソッドを表すPythonオブジェクトです。SQLAlchemyダイアレクトは、 <a class="reference internal" href="core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> クラスのサブクラスです。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/engines.html"><span class="std std-ref">Engine Configuration</span></a></p>
</div>
</dd>
<dt id="term-discriminator">discriminator<a class="headerlink" href="#term-discriminator" title="Link to this term">¶</a></dt><dd><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/inheritance.html"><span class="std std-ref">Mapping Class Inheritance Hierarchies</span></a></p>
</div>
</dd>
<dt id="term-DML">DML<a class="headerlink" href="#term-DML" title="Link to this term">¶</a></dt><dd><p><em>Data Manipulation Language*</em> の頭字語。DMLは、リレーショナル・データベースが表内のデータを*変更*するために使用するSQLのサブセットです。DMLは通常、INSERT、UPDATE、DELETEの3つの一般的な文を指します。これらは <a class="reference internal" href="#term-CRUD"><span class="xref std std-term">CRUD</span></a> (“Create, Read, Update, Delete”の頭字語)としても知られています。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Data_manipulation_language">DML (Wkipediaより)</a></p>
<p><a class="reference internal" href="#term-DDL"><span class="xref std std-term">DDL</span></a></p>
<p><a class="reference internal" href="#term-DQL"><span class="xref std std-term">DQL</span></a></p>
</div>
</dd>
<dt id="term-domain-model">domain model<a class="headerlink" href="#term-domain-model" title="Link to this term">¶</a></dt><dd><p>問題解決とソフトウェアエンジニアリングにおけるドメインモデルは、特定の問題に関連するすべてのトピックの概念モデルです。さまざまなエンティティ、その属性、役割、関係、および問題ドメインを管理する制約を記述します。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Domain_model">Domain Model (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-DQL">DQL<a class="headerlink" href="#term-DQL" title="Link to this term">¶</a></dt><dd><p><strong>Data Query Language</strong> の頭字語です。DQLは、リレーショナル・データベースが表内のデータを*読み取る*ために使用するSQLのサブセットです。DQLは、ほとんどの場合、使用中の最上位レベルのSQL文としてSQL SELECT構文を参照します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Data_query_language">DQL (Wkipediaより)</a></p>
<p><a class="reference internal" href="#term-DML"><span class="xref std std-term">DML</span></a></p>
<p><a class="reference internal" href="#term-DDL"><span class="xref std std-term">DDL</span></a></p>
</div>
</dd>
<dt id="term-durability">durability<a class="headerlink" href="#term-durability" title="Link to this term">¶</a></dt><dd><p>耐久性は <a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a> モデルの特性であり、一度コミットされたトランザクションは、停電、クラッシュ、エラーが発生した場合でもコミットされたままになることを意味します。例えば、リレーショナルデータベースでは、SQL文のグループが実行されると、その結果を永続的に保存する必要があります(その直後にデータベースがクラッシュした場合でも)。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Durability_(database_systems)">Durability (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-eager-load">eager load<a class="headerlink" href="#term-eager-load" title="Link to this term">¶</a></dt><dt id="term-eager-loads">eager loads<a class="headerlink" href="#term-eager-loads" title="Link to this term">¶</a></dt><dt id="term-eager-loaded">eager loaded<a class="headerlink" href="#term-eager-loaded" title="Link to this term">¶</a></dt><dt id="term-eager-loading">eager loading<a class="headerlink" href="#term-eager-loading" title="Link to this term">¶</a></dt><dt id="term-eagerly-load">eagerly load<a class="headerlink" href="#term-eagerly-load" title="Link to this term">¶</a></dt><dd><p>オブジェクトリレーショナルマッピングでは、”eager load”とは、オブジェクト自体がデータベースからロードされるのと同時に、データベース側の値が入力される属性を指します。SQLAlchemyでは、”eager loading”という用語は通常、 <a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 構文を使用してマッピング間でリンクされたオブジェクトの関連するコレクションとインスタンスを指しますが、 <a class="reference internal" href="orm/inheritance.html"><span class="std std-ref">inheritance</span></a> マッピングを使用する場合など、クエリされている特定のテーブルに関連する他のテーブルからロードされる追加の列属性を指すこともあります。</p>
<p>Eager loadingは <a class="reference internal" href="#term-lazy-loading"><span class="xref std std-term">lazy loading</span></a> の反対です。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/queryguide/relationships.html"><span class="doc">Relationship Loading Techniques</span></a></p>
</div>
</dd>
<dt id="term-executemany">executemany<a class="headerlink" href="#term-executemany" title="Link to this term">¶</a></dt><dd><p>この用語は、 <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> DBAPI仕様の一部で、複数のパラメータセットを持つデータベース接続に対して呼び出すことができる単一のSQL文を示します。この特定のメソッドは <a class="reference external" href="https://peps.python.org/pep-0249/#executemany">cursor.executemany()</a> として知られており、単一文の呼び出しに使用される <a class="reference external" href="https://peps.python.org/pep-0249/#execute">cursor.execute()</a> メソッドと比較して、多くの動作上の違いがあります。”executemany”メソッドは、渡されたパラメータセットごとに1回ずつ、指定されたSQL文を複数回実行します。executemanyを使用する一般的な理由は、パフォーマンスを向上させるためです。DBAPIは、事前に1回だけ文を準備したり、同じ文を複数回呼び出すように最適化するなどのテクニックを使用できます。</p>
<p>パラメータ辞書のリストが渡されたところで <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a> メソッドが使われると、SQLAlchemyは通常自動的に <code class="docutils literal notranslate"><span class="pre">cursor.executemany()</span></code> メソッドを利用します。これはSQLAlchemy Coreに対して、SQL文と処理されたパラメータセットを <code class="docutils literal notranslate"><span class="pre">cursor.executemany()</span></code> に渡す必要があることを示します。この場合、ドライバはパラメータ辞書ごとに個別にこの文を呼び出します。</p>
<p>既知のすべてのDB APIで使用されている <code class="docutils literal notranslate"><span class="pre">cursor.executemany()</span></code> メソッドの主な制限は、このメソッドを使用したときに <code class="docutils literal notranslate"><span class="pre">cursor</span></code> が行を返すように設定されていないことです。 <strong>ほとんどの</strong> バックエンド(cx_Oracle、/OracleDB DB APIは顕著な例外です)では、これは <code class="docutils literal notranslate"><span class="pre">INSERT.RETURNING</span></code> のような文は通常 <code class="docutils literal notranslate"><span class="pre">cursor.executemany()</span></code> と直接使用できないことを意味します。なぜなら、DB APIは通常、各INSERT実行から単一の行を集約しないからです。</p>
<p>この制限を克服するために、2.0シリーズのSQLAlchemyは <a class="reference internal" href="core/connections.html#engine-insertmanyvalues"><span class="std std-ref">“Insert Many Values” Behavior for INSERT statements</span></a> として知られる別の形式の”executemany”を実装しています。この機能は、 <code class="docutils literal notranslate"><span class="pre">cursor.execute()</span></code> を使用して、1回のラウンドトリップで複数のパラメータセットを処理するINSERT文を呼び出します。したがって、RETURNINGをサポートしながら、 <code class="docutils literal notranslate"><span class="pre">cursor.executemany()</span></code> を使用した場合と同じ効果が得られます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="tutorial/dbapi_transactions.html#tutorial-multiple-parameters"><span class="std std-ref">Sending Multiple Parameters</span></a> - “executemany”のチュートリアル入門</p>
<p><a class="reference internal" href="core/connections.html#engine-insertmanyvalues"><span class="std std-ref">“Insert Many Values” Behavior for INSERT statements</span></a> - RETURNINGを”executemany”で使用できるようにするSQLAlchemyの機能</p>
</div>
</dd>
<dt id="term-expire">expire<a class="headerlink" href="#term-expire" title="Link to this term">¶</a></dt><dt id="term-expired">expired<a class="headerlink" href="#term-expired" title="Link to this term">¶</a></dt><dt id="term-expires">expires<a class="headerlink" href="#term-expires" title="Link to this term">¶</a></dt><dt id="term-expiring">expiring<a class="headerlink" href="#term-expiring" title="Link to this term">¶</a></dt><dt id="term-Expiring">Expiring<a class="headerlink" href="#term-Expiring" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyのORMでは、 <a class="reference internal" href="#term-persistent"><span class="xref std std-term">persistent</span></a> オブジェクトや、時には <a class="reference internal" href="#term-detached"><span class="xref std std-term">detached</span></a> オブジェクトのデータがいつ消去されるかを参照します。オブジェクトの属性が次にアクセスされたとき、現在進行中のトランザクションに格納されているこのオブジェクトのデータを更新するために、 <a class="reference internal" href="#term-lazy-load"><span class="xref std std-term">lazy load</span></a> SQLクエリが発行されます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-expire"><span class="std std-ref">Refreshing / Expiring</span></a></p>
</div>
</dd>
<dt id="term-facade">facade<a class="headerlink" href="#term-facade" title="Link to this term">¶</a></dt><dd><p>より複雑な基礎または構造コードをマスクする、前面のインタフェースとして機能するオブジェクト。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Facade_pattern">Facade pattern (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-flush">flush<a class="headerlink" href="#term-flush" title="Link to this term">¶</a></dt><dt id="term-flushing">flushing<a class="headerlink" href="#term-flushing" title="Link to this term">¶</a></dt><dt id="term-flushed">flushed<a class="headerlink" href="#term-flushed" title="Link to this term">¶</a></dt><dd><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_basics.html#session-flushing"><span class="std std-ref">Flushing</span></a></p>
</div>
</dd>
<dt id="term-foreign-key-constraint">foreign key constraint<a class="headerlink" href="#term-foreign-key-constraint" title="Link to this term">¶</a></dt><dd><p>2つのテーブル間の参照制約です。外部キーは、他のテーブルの <a class="reference internal" href="#term-candidate-key"><span class="xref std std-term">candidate key</span></a> と一致するリレーショナルテーブル内のフィールドまたはフィールドのセットです。外部キーは、テーブルを相互参照するために使用できます。(Wikipediaより)</p>
<p>以下のように <a class="reference internal" href="#term-DDL"><span class="xref std std-term">DDL</span></a> を使用して、標準SQLのテーブルに外部キー制約を追加することができます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">dep_id_fk</span>
<span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">employee</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="p">(</span><span class="n">dep_id</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Foreign_key_constraint">Foreign Key Constraint (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-FROM-clause">FROM clause<a class="headerlink" href="#term-FROM-clause" title="Link to this term">¶</a></dt><dd><p>行の初期ソースを示す <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 文の部分です。</p>
<p>単純な <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> は、FROM句の中に1つ以上のテーブル名を持ちます。複数のソースはコンマで区切られます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="p">,</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span></pre></div>
</div>
<p>FROM句は、明示的な結合が指定される場所でもあります。2つのテーブルの <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> からなる単一の <code class="docutils literal notranslate"><span class="pre">FROM</span></code> 要素を使って、上記の <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> を書き直すことができます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span></pre></div>
</div>
</dd>
<dt id="term-identity-key">identity key<a class="headerlink" href="#term-identity-key" title="Link to this term">¶</a></dt><dd><p>ORMマップされたオブジェクトに関連付けられたキーで、データベース内での主キーのIDと、 <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 、 <a class="reference internal" href="#term-identity-map"><span class="xref std std-term">identity map</span></a> 内での一意のIDを識別します。</p>
<p>SQLAlchemyでは、 <a class="reference internal" href="core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> APIを使って <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.InstanceState" title="sqlalchemy.orm.InstanceState"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstanceState</span></code></a> 追跡オブジェクトを返し、 <code class="xref py py-attr docutils literal notranslate"><span class="pre">InstanceState.key</span></code> 属性を見ることで、ORMオブジェクトのIDキーを見ることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span><span class="o">.</span><span class="n">key</span>
<span class="go">(&lt;class &#39;__main__.MyTable&#39;&gt;, (1,), None)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-identity-map"><span class="xref std std-term">identity map</span></a></p>
</div>
</dd>
<dt id="term-identity-map">identity map<a class="headerlink" href="#term-identity-map" title="Link to this term">¶</a></dt><dd><p>PythonオブジェクトとそのデータベースID間のマッピングです。IDマップはORM <a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a> オブジェクトに関連付けられたコレクションで、そのIDにキー付けされた各データベースオブジェクトの単一のインスタンスを保持します。このパターンの利点は、特定のデータベースIDに対して行われるすべての操作が、単一のオブジェクトインスタンスに透過的に調整されることです。IDマップを <a class="reference internal" href="#term-isolated"><span class="xref std std-term">isolated</span></a> トランザクションと組み合わせて使用する場合、特定の主キーを持つことがわかっているオブジェクトへの参照を持つことは、実際のデータベース行へのプロキシであると実用的な観点から考えることができます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://martinfowler.com/eaaCatalog/identityMap.html">Identity Map (via Martin Fowler)</a></p>
<p><a class="reference internal" href="orm/session_basics.html#session-get"><span class="std std-ref">Get by Primary Key</span></a> - IDマップ内のオブジェクトをプライマリキーで検索する方法</p>
</div>
</dd>
<dt id="term-imperative">imperative<a class="headerlink" href="#term-imperative" title="Link to this term">¶</a></dt><dt id="term-declarative">declarative<a class="headerlink" href="#term-declarative" title="Link to this term">¶</a></dt><dd><p>SQLAlchemy ORMでは、これらの用語はPythonクラスをデータベース・テーブルにマッピングする2つの異なるスタイルを指します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/mapping_styles.html#orm-declarative-mapping"><span class="std std-ref">Declarative Mapping</span></a></p>
<p><a class="reference internal" href="orm/mapping_styles.html#orm-imperative-mapping"><span class="std std-ref">Imperative Mapping</span></a></p>
</div>
</dd>
<dt id="term-insertmanyvalues">insertmanyvalues<a class="headerlink" href="#term-insertmanyvalues" title="Link to this term">¶</a></dt><dd><p>これはSQLAlchemy特有の機能で、INSERT文が1つの文の中で何千もの新しい行を出力できるようにすると同時に、パフォーマンスを最適化する目的で、サーバが生成した値をRETURNINGなどを使用して文からインラインで返すことができます。この機能は、選択されたバックエンドで透過的に使用できるように意図されていますが、いくつかの設定オプションを提供します。この機能の詳細な説明については <a class="reference internal" href="core/connections.html#engine-insertmanyvalues"><span class="std std-ref">“Insert Many Values” Behavior for INSERT statements</span></a> を参照してください。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/connections.html#engine-insertmanyvalues"><span class="std std-ref">“Insert Many Values” Behavior for INSERT statements</span></a></p>
</div>
</dd>
<dt id="term-instrumentation">instrumentation<a class="headerlink" href="#term-instrumentation" title="Link to this term">¶</a></dt><dt id="term-instrumented">instrumented<a class="headerlink" href="#term-instrumented" title="Link to this term">¶</a></dt><dt id="term-instrumenting">instrumenting<a class="headerlink" href="#term-instrumenting" title="Link to this term">¶</a></dt><dd><p>インストルメンテーションとは、特定のクラスの機能と属性セットを拡張するプロセスを指します。理想的には、クラスの動作は、追加の動作と機能が利用可能になることを除いて、通常のクラスに近い状態を維持する必要があります。SQLAlchemy <a class="reference internal" href="#term-mapping"><span class="xref std std-term">mapping</span></a> プロセスは、特に、データベース対応の <a class="reference internal" href="#term-descriptors"><span class="xref std std-term">descriptors</span></a> を、それぞれが特定のデータベース列または関連クラスとの関係を表すマップされたクラスに追加します。</p>
</dd>
<dt id="term-isolation">isolation<a class="headerlink" href="#term-isolation" title="Link to this term">¶</a></dt><dt id="term-isolated">isolated<a class="headerlink" href="#term-isolated" title="Link to this term">¶</a></dt><dt id="term-isolation-level">isolation level<a class="headerlink" href="#term-isolation-level" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a> モデルの独立性プロパティは、トランザクションの同時実行が、トランザクションが連続して実行された場合、つまり次々に実行された場合に得られるシステム状態になることを保証します。各トランザクションは完全に分離して実行する必要があります。つまり、T1とT2が同時に実行される場合、それぞれが互いに独立している必要があります。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-ACID"><span class="xref std std-term">ACID</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">Isolation (Wkipediaより)</a></p>
<p><a class="reference internal" href="#term-read-uncommitted"><span class="xref std std-term">read uncommitted</span></a></p>
<p><a class="reference internal" href="#term-read-committed"><span class="xref std std-term">read committed</span></a></p>
<p><a class="reference internal" href="#term-repeatable-read"><span class="xref std std-term">repeatable read</span></a></p>
<p><a class="reference internal" href="#term-serializable"><span class="xref std std-term">serializable</span></a></p>
</div>
</dd>
<dt id="term-lazy-initialization">lazy initialization<a class="headerlink" href="#term-lazy-initialization" title="Link to this term">¶</a></dt><dd><p>オブジェクトの作成、データの取り込み、または他のサービスへの接続の確立などの初期化アクションを、それらのリソースが必要になるまで遅延させる戦術。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_initialization">Lazy initialization (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-lazy-load">lazy load<a class="headerlink" href="#term-lazy-load" title="Link to this term">¶</a></dt><dt id="term-lazy-loads">lazy loads<a class="headerlink" href="#term-lazy-loads" title="Link to this term">¶</a></dt><dt id="term-lazy-loaded">lazy loaded<a class="headerlink" href="#term-lazy-loaded" title="Link to this term">¶</a></dt><dt id="term-lazy-loading">lazy loading<a class="headerlink" href="#term-lazy-loading" title="Link to this term">¶</a></dt><dd><p>オブジェクト・リレーショナル・マッピングでは、”遅延ロード”とは、通常はオブジェクトが最初にロードされるときに、ある期間データベース側の値を含まない属性を指します。その代わりに、属性は <em>メモ化</em> を受け取り、データベースに送信され、最初に使用されたときにデータをロードします。このパターンを使用すると、関連するテーブルの属性をすぐに処理する必要がないため、オブジェクト・フェッチの複雑さと時間を削減できる場合があります。</p>
<p>遅延読み込みは <a class="reference internal" href="#term-eager-loading"><span class="xref std std-term">eager loading</span></a> の反対です。</p>
<p>SQLAlchemyでは、遅延読み込みはORMの重要な機能であり、ユーザ定義クラスの <a class="reference internal" href="#term-mapped"><span class="xref std std-term">mapped</span></a> 属性に適用されます。データベース列や関連するオブジェクトを参照する属性がアクセスされ、その属性にロードされた値が存在しない場合、ORMは現在のオブジェクトが <a class="reference internal" href="#term-persistent"><span class="xref std std-term">persistent</span></a> 状態で関連付けられている <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> を利用し、現在のトランザクションでSELECT文を発行し、進行中でなければ新しいトランザクションを開始します。オブジェクトが <a class="reference internal" href="#term-detached"><span class="xref std std-term">detached</span></a> 状態で、どの <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> とも関連付けられていない場合、これはエラー状態とみなされ、 <a class="reference internal" href="errors.html#error-bhk3"><span class="std std-ref">informational exception</span></a> が発生します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://martinfowler.com/eaaCatalog/lazyLoad.html">Lazy Load (via Martin Fowler)</a> <a class="reference internal" href="#term-N-plus-one-problem"><span class="xref std std-term">N plus one problem</span></a></p>
<p><a class="reference internal" href="orm/queryguide/columns.html#loading-columns"><span class="std std-ref">Column Loading Options</span></a> - ORMマップされた列の遅延読み込みに関する情報を含みます</p>
<p><a class="reference internal" href="orm/queryguide/relationships.html"><span class="doc">Relationship Loading Techniques</span></a> - ORM関連オブジェクトの遅延読み込みに関する情報を含んでいます</p>
<p><a class="reference internal" href="orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads"><span class="std std-ref">Preventing Implicit IO when Using AsyncSession</span></a> - <a class="reference internal" href="orm/extensions/asyncio.html"><span class="std std-ref">Asynchronous I/O (asyncio)</span></a> 拡張を使用する際に遅延読み込みを避けるためのヒント</p>
</div>
</dd>
<dt id="term-many-to-many">many to many<a class="headerlink" href="#term-many-to-many" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqlalchemy.orm.relationship()</span></code></a> のスタイルで、中間のテーブルを介して2つのテーブルをリンクします。この設定を使用すると、左側の任意の数の行が右側の任意の数の行を参照することができ、その逆も可能です。</p>
<p>従業員をプロジェクトに関連付けることができるスキーマ:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee_project</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">employee_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">project_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">employee_id</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">employee</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">project_id</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">project</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上の例では、 <code class="docutils literal notranslate"><span class="pre">employee_project</span></code> テーブルは多対多のテーブルであり、関連する各テーブルのプライマリキーからなる複合主キーを自然に形成します。</p>
<p>SQLAlchemyでは、 <code class="xref py py-func docutils literal notranslate"><span class="pre">SQLAlchemy.orm.relationship()</span></code> 関数はこのスタイルの関係をほとんど透過的に表現することができ、多対多のテーブルは普通のテーブルメタデータを使って指定されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">projects</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Project&quot;</span><span class="p">,</span>
        <span class="n">secondary</span><span class="o">=</span><span class="n">Table</span><span class="p">(</span>
            <span class="s2">&quot;employee_project&quot;</span><span class="p">,</span>
            <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;employee_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;employee.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;project_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;project.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;employees&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Project</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;project&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上記では、 <code class="docutils literal notranslate"><span class="pre">Employee.projects</span></code> コレクションと後方参照 <code class="docutils literal notranslate"><span class="pre">Project.employees</span></code> コレクションが定義されています。</p>
<blockquote>
<div><p>proj = Project(name=”Client A”)</p>
<p>emp1 = Employee(name=”emp1”)
emp2 = Employee(name=”emp2”)</p>
<p>proj.employees.extend([emp1, emp2])</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-association-relationship"><span class="xref std std-term">association relationship</span></a></p>
<p><a class="reference internal" href="#term-relationship"><span class="xref std std-term">relationship</span></a></p>
<p><a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a></p>
<p><a class="reference internal" href="#term-many-to-one"><span class="xref std std-term">many to one</span></a></p>
</div>
</dd>
<dt id="term-many-to-one">many to one<a class="headerlink" href="#term-many-to-one" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> のスタイルで、親マッパーのテーブル内の外部キーを関連するテーブルのプライマリキーにリンクします。各親オブジェクトは、正確に0個または1個の関連するオブジェクトを参照できます。</p>
<p>関連するオブジェクトは、それらを参照する任意の数の親オブジェクトに対して、暗黙的または明示的な <a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a> 関係を持ちます。</p>
<p>多対1スキーマの例(これは <a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a> スキーマと同じであることに注意してください):</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
<span class="w">    </span><span class="n">dep_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">department</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">employee</span></code> から <code class="docutils literal notranslate"><span class="pre">department</span></code> への関係は、多数の従業員レコードを1つの部署に関連付けることができるため、多対1です。SQLAlchemyマッピングは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Department</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;department&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">dep_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;department.id&quot;</span><span class="p">))</span>
    <span class="n">department</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Department&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-relationship"><span class="xref std std-term">relationship</span></a></p>
<p><a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a></p>
<p><a class="reference internal" href="#term-backref"><span class="xref std std-term">backref</span></a></p>
</div>
</dd>
<dt id="term-mapping">mapping<a class="headerlink" href="#term-mapping" title="Link to this term">¶</a></dt><dt id="term-mapped">mapped<a class="headerlink" href="#term-mapped" title="Link to this term">¶</a></dt><dt id="term-mapped-class">mapped class<a class="headerlink" href="#term-mapped-class" title="Link to this term">¶</a></dt><dt id="term-ORM-mapped-class">ORM mapped class<a class="headerlink" href="#term-ORM-mapped-class" title="Link to this term">¶</a></dt><dd><p>クラスが <a class="reference internal" href="orm/mapping_api.html#sqlalchemy.orm.Mapper" title="sqlalchemy.orm.Mapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code></a> クラスのインスタンスに関連付けられている場合、そのクラスは”マップされている”と言います。このプロセスはクラスをデータベーステーブルや他の <a class="reference internal" href="#term-selectable"><span class="xref std std-term">selectable</span></a> 構成体に関連付け、そのインスタンスが <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> を使って永続化されロードされるようにします。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/mapping_styles.html"><span class="std std-ref">ORM Mapped Class Overview</span></a></p>
</div>
</dd>
<dt id="term-marshalling">marshalling<a class="headerlink" href="#term-marshalling" title="Link to this term">¶</a></dt><dt id="term-data-marshalling">data marshalling<a class="headerlink" href="#term-data-marshalling" title="Link to this term">¶</a></dt><dd><p>コンピュータプログラムの異なる部分間で、またはあるプログラムから別のプログラムにデータを移動する必要がある場合に、オブジェクトのメモリ表現を、システムの別の部分への格納または転送に適したデータ形式に変換するプロセス。SQLAlchemyに関しては、リレーショナル・データベースに渡すのに適した形式にデータを”マーシャリング”する必要があります。</p>
<blockquote>
<div><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">Marshalling (Wkipediaより)</a></p>
<p><a class="reference internal" href="core/custom_types.html#types-typedecorator"><span class="std std-ref">Augmenting Existing Types</span></a> - SQLAlchemyの <a class="reference internal" href="core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> は、データがINSERT文とUPDATE文のためにデータベースに送られるときのデータのマーシャリングと、SELECT文を使って取得されるときのデータの”アンマーシャリング”によく使われます。</p>
</div>
</div></blockquote>
</dd>
<dt id="term-metadata">metadata<a class="headerlink" href="#term-metadata" title="Link to this term">¶</a></dt><dt id="term-database-metadata">database metadata<a class="headerlink" href="#term-database-metadata" title="Link to this term">¶</a></dt><dt id="term-table-metadata">table metadata<a class="headerlink" href="#term-table-metadata" title="Link to this term">¶</a></dt><dd><p>“メタデータ”という用語は、一般に”データを記述するデータ”、つまり、それ自体が何らかの他の種類のデータのフォーマットおよび/または構造を表すデータを指します。SQLAlchemyでは、”メタデータ”という用語は通常、特定のデータベースに存在する可能性のあるテーブル、カラム、制約、およびその他の <a class="reference internal" href="#term-DDL"><span class="xref std std-term">DDL</span></a> オブジェクトに関する情報のコレクションである <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 構造を指します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://www.martinfowler.com/eaaCatalog/metadataMapping.html">Metadata Mapping (via Martin Fowler)</a></p>
<p><a class="reference internal" href="tutorial/metadata.html#tutorial-working-with-metadata"><span class="std std-ref">Working with Database Metadata</span></a>  - <a class="reference internal" href="tutorial/index.html#unified-tutorial"><span class="std std-ref">SQLAlchemy Unified Tutorial</span></a></p>
</div>
</dd>
<dt id="term-method-chaining">method chaining<a class="headerlink" href="#term-method-chaining" title="Link to this term">¶</a></dt><dt id="term-generative">generative<a class="headerlink" href="#term-generative" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyドキュメント内で”ジェネレーティブ”と呼ばれる”メソッドチェーニング”は、オブジェクト上のメソッドを呼び出すことによってオブジェクトの状態を構築するオブジェクト指向のテクニックです。オブジェクトには任意の数のメソッドがあり、それぞれが新しいオブジェクト(場合によっては同じオブジェクト)を返し、オブジェクトに追加の状態が追加されます。</p>
<p>メソッドチェーニングを最大限に活用している2つのSQLAlchemyオブジェクトは、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> オブジェクトと <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> オブジェクトです。例えば、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> オブジェクトは、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> メソッドと <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a> メソッドを呼び出すことで、WHERE句とORDER BY句に2つの式を割り当てることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;e%&quot;</span><span class="p">))</span>
    <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記の各メソッド呼び出しは、元の <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> オブジェクト追加の修飾子が追加されたコピーを返します。</p>
</dd>
<dt id="term-mixin-class">mixin class<a class="headerlink" href="#term-mixin-class" title="Link to this term">¶</a></dt><dt id="term-mixin-classes">mixin classes<a class="headerlink" href="#term-mixin-classes" title="Link to this term">¶</a></dt><dd><p>他のクラスによって使用されるメソッドまたは属性を含むクラスが、それらの他のクラスの親クラスである必要がない、共通のオブジェクト指向パターン。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Mixin">Mixin (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-N-plus-one-problem">N plus one problem<a class="headerlink" href="#term-N-plus-one-problem" title="Link to this term">¶</a></dt><dt id="term-N-plus-one">N plus one<a class="headerlink" href="#term-N-plus-one" title="Link to this term">¶</a></dt><dd><p>N+1の問題は、 <a class="reference internal" href="#term-lazy-load"><span class="xref std std-term">lazy load</span></a> パターンの一般的な副作用です。このパターンでは、アプリケーションはオブジェクトの結果セットの各メンバの関連する属性またはコレクションを繰り返し処理し、その属性またはコレクションは遅延ロードパターンを介してロードされるように設定されます。最終的には、親オブジェクトの最初の結果セットをロードするためにSELECTステートメントが発行されます。次に、アプリケーションが各メンバを繰り返し処理すると、そのメンバの関連する属性またはコレクションをロードするために、各メンバに対して追加のSELECTステートメントが発行されます。最終的には、N個の親オブジェクトの結果セットに対して、N+1個のSELECTステートメントが発行されます。</p>
<p>The N plus one problem is alleviated using <a class="reference internal" href="#term-eager-loading"><span class="xref std std-term">eager loading</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="tutorial/orm_related_objects.html#tutorial-orm-loader-strategies"><span class="std std-ref">Loader Strategies</span></a></p>
<p><a class="reference internal" href="orm/queryguide/relationships.html"><span class="doc">Relationship Loading Techniques</span></a></p>
</div>
</dd>
<dt id="term-one-to-many">one to many<a class="headerlink" href="#term-one-to-many" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> のスタイルで、親マッパーのテーブルの主キーを関連テーブルの外部キーにリンクします。それぞれの一意の親オブジェクトは、0個以上の一意の関連オブジェクトを参照できます。</p>
<p>関連するオブジェクトは、親オブジェクトに対して暗黙的または明示的な <a class="reference internal" href="#term-many-to-one"><span class="xref std std-term">many to one</span></a> 関係を持ちます。</p>
<p>1対多のスキーマの例(これは <a class="reference internal" href="#term-many-to-one"><span class="xref std std-term">many to one</span></a> スキーマと同じであることに注意してください:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
<span class="w">    </span><span class="n">dep_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">department</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>1つの部署に複数の従業員レコードを関連付けることができるので、 <code class="docutils literal notranslate"><span class="pre">部署</span></code> から <code class="docutils literal notranslate"><span class="pre">従業員</span></code> への関係は1対多になります。SQLAlchemyマッピングは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Department</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;department&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">dep_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;department.id&quot;</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-relationship"><span class="xref std std-term">relationship</span></a></p>
<p><a class="reference internal" href="#term-many-to-one"><span class="xref std std-term">many to one</span></a></p>
<p><a class="reference internal" href="#term-backref"><span class="xref std std-term">backref</span></a></p>
</div>
</dd>
<dt id="term-ORM-annotated">ORM-annotated<a class="headerlink" href="#term-ORM-annotated" title="Link to this term">¶</a></dt><dt id="term-annotations">annotations<a class="headerlink" href="#term-annotations" title="Link to this term">¶</a></dt><dd><p>“ORM-annotated”というフレーズは、SQLAlchemyの内部的な側面を指します。ここでは、 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> オブジェクトのようなCoreオブジェクトは、特定のORMマッピングに属することを示す追加の実行時情報を持つことができます。この用語は、 <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> で紹介された静的型付けに使用されるPythonソースコードの”型ヒント”を指す一般的なフレーズ”型アノテーション”と混同しないでください。</p>
<p>SQLAlchemyの文書化されたコード例のほとんどは、”Annotated Example”または”Non-annotated Example”に関する小さな注記でフォーマットされています。これは例が <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 注釈付きであるかどうかを示し、”ORM-annotated”というSQLAlchemyの概念とは関係ありません。</p>
<p>ドキュメントに”ORM-annotated”というフレーズがある場合、これは <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 、 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> オブジェクトなどのコアSQL式オブジェクトを参照しています。これらのオブジェクトは、1つまたは複数のORMマッピングから生成されるか、またはORMマッピングから生成されるサブ要素を参照します。したがって、 <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> などのORMメソッドに渡されると、ORM固有の解釈や動作が行われます。たとえば、 <a class="reference internal" href="tutorial/metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">ORM Tutorial</span></a> に示されている <code class="docutils literal notranslate"><span class="pre">User</span></code> クラスのようなORMマッピングから <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> オブジェクトを構築する場合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span></pre></div>
</div>
<p>上記の <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> の内部状態は、”User”がマップされている <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> を参照しています。”User”クラス自体はすぐには参照されません。このようにして、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 構文はコアレベルのプロセスと互換性を保っています( <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> の <code class="docutils literal notranslate"><span class="pre">._raw_columns</span></code> メンバーはprivateであり、エンドユーザコードからはアクセスできないことに注意してください):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span><span class="o">.</span><span class="n">_raw_columns</span>
<span class="go">[Table(&#39;user_account&#39;, MetaData(), Column(&#39;id&#39;, Integer(), ...)]</span></pre></div>
</div>
<p>しかし、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> がORM <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> に渡されると、オブジェクトに間接的に関連付けられたORMエンティティが、この <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> をORMコンテキストで解釈するために使用されます。実際の”ORMアノテーション”は、別のプライベート変数 <code class="docutils literal notranslate"><span class="pre">._annotations</span></code> で確認することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_annotations</span>
<span class="go">immutabledict({</span>
<span class="go">  &#39;entity_namespace&#39;: &lt;Mapper at 0x7f4dd8098c10; User&gt;,</span>
<span class="go">  &#39;parententity&#39;: &lt;Mapper at 0x7f4dd8098c10; User&gt;,</span>
<span class="go">  &#39;parentmapper&#39;: &lt;Mapper at 0x7f4dd8098c10; User&gt;</span>
<span class="go">})</span></pre></div>
</div>
<p>したがって、ここでは <code class="docutils literal notranslate"><span class="pre">stmt</span></code> を <strong>ORMアノテーション付きのselect()</strong> オブジェクトと呼びます。これは <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 文で、 <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> のようなメソッドに渡されたときにORM固有の方法で解釈される追加情報を含んでいます。</p>
</dd>
<dt id="term-pending">pending<a class="headerlink" href="#term-pending" title="Link to this term">¶</a></dt><dd><p>これは、オブジェクトが <a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a> 内で持つことができる主要なオブジェクト状態の1つを記述します。pendingオブジェクトとは、データベースIDを持たないが、最近セッションに関連付けられた新しいオブジェクトです。セッションがフラッシュを発行し、行が挿入されると、オブジェクトは <a class="reference internal" href="#term-persistent"><span class="xref std std-term">persistent</span></a> 状態に移行します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a></p>
</div>
</dd>
<dt id="term-persistent">persistent<a class="headerlink" href="#term-persistent" title="Link to this term">¶</a></dt><dd><p>これは、オブジェクトが <a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a> 内で持つことができる主要なオブジェクト状態の1つを記述します。永続オブジェクトとは、データベースID(すなわち主キー)を持ち、現在セッションに関連付けられているオブジェクトです。以前 <a class="reference internal" href="#term-pending"><span class="xref std std-term">pending</span></a> であったオブジェクトが現在挿入されている場合は、データベースからセッションによってロードされたオブジェクトと同様に永続状態になります。永続オブジェクトがセッションから削除された場合、それは <a class="reference internal" href="#term-detached"><span class="xref std std-term">detached</span></a> と呼ばれます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a></p>
</div>
</dd>
<dt id="term-plugin">plugin<a class="headerlink" href="#term-plugin" title="Link to this term">¶</a></dt><dt id="term-plugin-enabled">plugin-enabled<a class="headerlink" href="#term-plugin-enabled" title="Link to this term">¶</a></dt><dt id="term-plugin-specific">plugin-specific<a class="headerlink" href="#term-plugin-specific" title="Link to this term">¶</a></dt><dd><p>“plugin-enabled”または”plugin-specific”は一般に、SQLAlchemy Coreの関数またはメソッドがORMコンテキストで使用された場合の動作が異なることを示します。</p>
<p>SQLAlchemyでは、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> オブジェクトのようなCore構成体を”プラグイン”システムに参加させることができ、デフォルトでは存在しない追加の振る舞いや機能をオブジェクトに注入することができます。</p>
<p>具体的には、主要な”プラグイン”は”orm”プラグインであり、SQLAlchemy ORMがORM結果を返すSQLクエリを作成して実行するためにCoreコンストラクトを利用するシステムのベースにあります。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="changelog/migration_20.html#migration-20-unify-select"><span class="std std-ref">ORM Query Unified with Core Select</span></a></p>
</div>
</dd>
<dt id="term-polymorphic">polymorphic<a class="headerlink" href="#term-polymorphic" title="Link to this term">¶</a></dt><dt id="term-polymorphically">polymorphically<a class="headerlink" href="#term-polymorphically" title="Link to this term">¶</a></dt><dd><p>一度に複数の型を処理する関数を指します。SQLAlchemyでは、この用語は通常、ORMマップされたクラスの概念に適用されます。これにより、クエリ操作は結果セット内の情報に基づいて、通常は <a class="reference internal" href="#term-discriminator"><span class="xref std std-term">discriminator</span></a> として知られる結果内の特定の列の値をチェックすることによって、異なるサブクラスを返します。</p>
<p>SQLAlchemyにおけるポリモーフィックなロードは、クラスの階層をマップするために、”joined”、”single”、”concrete”の3つの異なるスキームの1つまたは組み合わせが使用されることを意味します。セクション <a class="reference internal" href="orm/inheritance.html"><span class="std std-ref">Mapping Class Inheritance Hierarchies</span></a> では、継承マッピングについて詳しく説明しています。</p>
</dd>
<dt id="term-primary-key">primary key<a class="headerlink" href="#term-primary-key" title="Link to this term">¶</a></dt><dt id="term-primary-key-constraint">primary key constraint<a class="headerlink" href="#term-primary-key-constraint" title="Link to this term">¶</a></dt><dd><p>テーブル内の各行の特性を一意に定義する <a class="reference internal" href="#term-constraint"><span class="xref std std-term">constraint</span></a> 。主キーは、他の行では複製できない特性で構成されている必要があります。主キーは、単一の属性または組み合わせた複数の属性で構成できます。(Wikipediaより)</p>
<p>テーブルのプライマリキーは、必ずではありませんが、一般的には <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> <a class="reference internal" href="#term-DDL"><span class="xref std std-term">DDL</span></a> 内で定義されます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">     </span><span class="n">emp_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">     </span><span class="n">emp_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
<span class="w">     </span><span class="n">dep_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">     </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#term-composite-primary-key"><span class="xref std std-term">composite primary key</span></a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Primary_Key">Primary key (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-read-committed">read committed<a class="headerlink" href="#term-read-committed" title="Link to this term">¶</a></dt><dd><p>4つのdatabase <a class="reference internal" href="#term-isolation"><span class="xref std std-term">isolation</span></a> レベルの1つで、コミットされた読み込み機能は、まだコミットされていない他の同時実行中のトランザクションからのいかなるデータにもトランザクションがさらされないようにし、いわゆる”ダーティリード”を防ぎます。しかし、コミットされた読み込みでは、繰り返し不可能な読み込みがある可能性があります。つまり、別のトランザクションが変更をコミットした場合、2回目の読み込み時に行内のデータが変更される可能性があります。</p>
</dd>
<dt id="term-read-uncommitted">read uncommitted<a class="headerlink" href="#term-read-uncommitted" title="Link to this term">¶</a></dt><dd><p>4つのdatabase <a class="reference internal" href="#term-isolation"><span class="xref std std-term">isolation</span></a> レベルの1つで、トランザクション内でデータベースデータに加えられた変更が、トランザクションがコミットされるまで永続的にならないread uncommitted機能です。しかし、read uncommittedでは、他のトランザクションでコミットされていないデータが、別のトランザクションのスコープ内で表示される可能性があります。これは”ダーティリード”と呼ばれます。</p>
</dd>
<dt id="term-reflection">reflection<a class="headerlink" href="#term-reflection" title="Link to this term">¶</a></dt><dt id="term-reflected">reflected<a class="headerlink" href="#term-reflected" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyでは、この用語は、既存のテーブル、列、制約、およびその他の構成体に関する情報をロードするために、データベースのスキーマカタログを照会する機能を指します。SQLAlchemyには、この情報の生データを提供する機能と、データベーススキーマカタログからCore/ORMで使用可能な <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> オブジェクトを自動的に構築する機能の両方が含まれています。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/reflection.html"><span class="std std-ref">Reflecting Database Objects</span></a> - データベースリフレクションのバックグラウンドです。</p>
<p><a class="reference internal" href="orm/declarative_tables.html#orm-declarative-reflected"><span class="std std-ref">Mapping Declaratively with Reflected Tables</span></a> - ORMマッピングとリフレクトされたテーブルの統合に関するバックグラウンドです。</p>
</div>
</dd>
<dt id="term-registry">registry<a class="headerlink" href="#term-registry" title="Link to this term">¶</a></dt><dd><p>通常はグローバルにアクセス可能なオブジェクトで、プログラムの多くの部分で一般的に有用な、プログラムの状態に関する長期にわたる情報を含みます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://martinfowler.com/eaaCatalog/registry.html">Registry (via Martin Fowler)</a></p>
</div>
</dd>
<dt id="term-relational">relational<a class="headerlink" href="#term-relational" title="Link to this term">¶</a></dt><dt id="term-relational-algebra">relational algebra<a class="headerlink" href="#term-relational-algebra" title="Link to this term">¶</a></dt><dd><p>リレーショナル・データベースに格納されたデータのモデリングとクエリーに使用される、Edgar F. Coddによって開発された代数的システム。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Relational_algebra">Relational Algebra (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-relationship">relationship<a class="headerlink" href="#term-relationship" title="Link to this term">¶</a></dt><dt id="term-relationships">relationships<a class="headerlink" href="#term-relationships" title="Link to this term">¶</a></dt><dd><p>データベース内の2つのテーブル間の関係に対応する、2つのマップされたクラスを接続するユニットです。</p>
<p>関係はSQLAlchemy関数 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> を使用して定義されます。一度作成されると、SQLAlchemyは関係を3つのタイプ <a class="reference internal" href="#term-one-to-many"><span class="xref std std-term">one to many</span></a> , <a class="reference internal" href="#term-many-to-one"><span class="xref std std-term">many to one</span></a> , <a class="reference internal" href="#term-many-to-many"><span class="xref std std-term">many to many</span></a> のいずれかに分類するために、関連する引数と基礎となるマッピングを検査します。この分類では、関係構造は、メモリー内のオブジェクトの関連付けに応じてデータベース内に適切なリンクを保持するタスクと、データベース内の現在のリンクに基づいてオブジェクト参照とコレクションをメモリーにロードするジョブを処理します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/relationships.html"><span class="std std-ref">Relationship Configuration</span></a></p>
</div>
</dd>
<dt id="term-release">release<a class="headerlink" href="#term-release" title="Link to this term">¶</a></dt><dt id="term-releases">releases<a class="headerlink" href="#term-releases" title="Link to this term">¶</a></dt><dt id="term-released">released<a class="headerlink" href="#term-released" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyの文脈では、”release”という用語は、特定のデータベース接続の使用を終了するプロセスを指します。SQLAlchemyは、接続プールの使用を特徴とし、データベース接続の寿命に関して構成可能性を可能にします。プールされた接続を使用する場合、それを”閉じる”プロセス、すなわち <code class="docutils literal notranslate"><span class="pre">connection.</span> <span class="pre">close()</span></code> のような文を呼び出すプロセスは、接続が既存のプールに戻される効果を持つこともあれば、その接続によって参照される基礎となるTCP/IP接続を実際にシャットダウンする効果を持つこともあります。どちらが行われるかは、構成とプールの現在の状態に依存します。そのため、代わりに”接続の使用が終了したら、接続に対して行うことは何でも行う”という意味で”release”という用語を使用しました。</p>
<p>この用語は、”トランザクションリソースを解放する”というフレーズで使用されることがあります。これは、実際に”解放”しているものが、接続時に蓄積されたトランザクション状態であることをより明確に示すためです。ほとんどの場合、テーブルから選択したり、更新を発行したりするプロセスなどは、その接続時に <a class="reference internal" href="#term-isolated"><span class="xref std std-term">isolated</span></a> 状態と、潜在的なローまたはテーブルロックを取得します。この状態はすべて、接続上の特定のトランザクションに対してローカルであり、ロールバックを発行すると解放されます。接続プールの重要な機能は、接続をプールに戻すときに、DBAPIの <code class="docutils literal notranslate"><span class="pre">connection.</span> <span class="pre">rollback()</span></code> メソッドも呼び出されることです。これにより、接続が再度使用されるように設定されると、前の一連の操作への参照が保持されない”クリーン”状態になります。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/pooling.html"><span class="std std-ref">Connection Pooling</span></a></p>
</div>
</dd>
<dt id="term-repeatable-read">repeatable read<a class="headerlink" href="#term-repeatable-read" title="Link to this term">¶</a></dt><dd><p>4つのdatabase <a class="reference internal" href="#term-isolation"><span class="xref std std-term">isolation</span></a> レベルの1つであるrepeatable readは、 <a class="reference internal" href="#term-read-committed"><span class="xref std std-term">read committed</span></a> のすべての独立性を特徴とし、さらに、トランザクション内で読み取られる特定の行は、その時点から、そのトランザクションの間、値が外部から変更されないこと(つまり、他の同時UPDATE文から)が保証されるという特徴があります。</p>
</dd>
<dt id="term-RETURNING">RETURNING<a class="headerlink" href="#term-RETURNING" title="Link to this term">¶</a></dt><dd><p>これは、特定のバックエンドによってさまざまな形式で提供される非SQL標準句で、INSERT、UPDATE、またはDELETE文の実行時に結果セットを返すサービスを提供します。SELECT文から生成されたかのように、一致したローから任意のカラムのセットを返すことができます。</p>
<p>RETURNING句を使用すると、インラインまたはデフォルトで生成されたプライマリ・キー値とデフォルト値をそれらが作成された時点で取得するなど、一般的な更新/選択シナリオのパフォーマンスが大幅に向上します。また、サーバで生成されたデフォルト値をアトミックな方法で取得することもできます。</p>
<p>PostgreSQLの慣用表現であるRETURNINGの例は以下のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;new name&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">timestamp</span></pre></div>
</div>
<p>上の例では、INSERT文は実行時に結果セットを提供します。この結果セットには、 <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> 列と <code class="docutils literal notranslate"><span class="pre">user_account.timestamp</span></code> 列の値が含まれています。これらの列は、他の方法では含まれないので、デフォルト値として生成されるはずです(ただし、デフォルト値の列だけでなく、任意の列やSQL式をRETURNINGに入れることができることに注意してください)。</p>
<p>現在RETURNINGまたは同様の構文をサポートしているバックエンドは、PostgreSQL、SQL Server、Oracle、およびFirebirdです。PostgreSQLおよびFirebirdの実装は一般的にフル機能ですが、SQL ServerおよびOracleの実装には注意事項があります。SQL Serverでは、この句はINSERT文およびUPDATE文の場合は”OUTPUT INSERTED”、DELETE文の場合は”OUTPUT DELETED”と呼ばれます。重要な注意事項は、このキーワードと一緒にトリガを使用できないことです。Oracleでは、これは”RETURNING…INTO”と呼ばれ、値をOUTパラメータに入れる必要があります。これは構文が厄介であるだけでなく、一度に1つの行にしか使用できないことを意味します。</p>
<p>SQLAlchemyの <a class="reference internal" href="core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning" title="sqlalchemy.sql.expression.UpdateBase.returning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">UpdateBase.returning()</span></code></a> システムは、これらのバックエンドのRETURNINGシステムの上に抽象層を提供して、列を返すための一貫したインターフェースを提供します。ORMには、利用可能な場合にRETURNINGを利用する多くの最適化も含まれています。</p>
</dd>
<dt id="term-selectable">selectable<a class="headerlink" href="#term-selectable" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyで使用される用語で、行の集合を表すSQL構文を表します。 <a class="reference internal" href="#term-relational-algebra"><span class="xref std std-term">relational algebra</span></a> の”リレーション”の概念とほぼ同じです。SQLAlchemyでは、 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Selectable" title="sqlalchemy.sql.expression.Selectable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Selectable</span></code></a> クラスをサブクラス化したオブジェクトは、SQLAlchemy Coreを使用するときに”selectables”として使用できると見なされます。最も一般的な2つの構文は、 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> と <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 文の構文です。</p>
</dd>
<dt id="term-sentinel">sentinel<a class="headerlink" href="#term-sentinel" title="Link to this term">¶</a></dt><dt id="term-insert-sentinel">insert sentinel<a class="headerlink" href="#term-insert-sentinel" title="Link to this term">¶</a></dt><dd><p>これはSQLAlchemy特有の用語で、<a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> を参照します。これはバルクの <a class="reference internal" href="#term-insertmanyvalues"><span class="xref std std-term">insertmanyvalues</span></a> 操作で使用でき、RETURNINGなどを使用して返された行に対して挿入されたデータレコードを追跡します。このような列設定は、 <a class="reference internal" href="#term-insertmanyvalues"><span class="xref std std-term">insertmanyvalues</span></a> 機能が一度に多くの行に対して最適化されたINSERT.RETURNING文を実行し、返された行の順序が入力データと一致することを保証できる場合に必要です。</p>
<p>典型的なユースケースでは、SQLAlchemy SQLコンパイラは自動的に”insert sentinel”としてサロゲート整数のプライマリキー列を使用することができ、ユーザによる設定は必要ありません。他の種類のサーバ生成プライマリキー値を使用するあまり一般的でないケースでは、一度に多くの行を挿入するINSERT文を最適化するために、 <a class="reference internal" href="#term-table-metadata"><span class="xref std std-term">table metadata</span></a> 内で明示的な”insert sentinel”列をオプションで設定できます。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/connections.html#engine-insertmanyvalues-returning-order"><span class="std std-ref">Correlating RETURNING rows to parameter sets</span></a> - このセクションにあります。
<a class="reference internal" href="core/connections.html#engine-insertmanyvalues"><span class="std std-ref">“Insert Many Values” Behavior for INSERT statements</span></a></p>
</div>
</dd>
<dt id="term-serializable">serializable<a class="headerlink" href="#term-serializable" title="Link to this term">¶</a></dt><dd><p>4つのデータベース <a class="reference internal" href="#term-isolation"><span class="xref std std-term">isolation</span></a> レベルの1つであるシリアライザブル機能は、 <a class="reference internal" href="#term-repeatable-read"><span class="xref std std-term">repeatable read</span></a> のすべての独立性を備えています。さらに、ロックベースのアプローチでは、いわゆる”phantom reads”が発生しないことが保証されています。つまり、他のトランザクションのスコープ内で挿入または削除された行は、このトランザクション内では検出できません。このトランザクション内で読み取られた行は存在し続けることが保証され、存在しない行は他のトランザクションから表示または挿入されないことが保証されます。</p>
<p>シリアライズ可能な分離は、通常、この効果を達成するために行または行の範囲のロックに依存しており、デッドロックの可能性を高め、パフォーマンスを低下させる可能性があります。ロックベースでないスキームもあるが、これらは、書き込み衝突が検出された場合にトランザクションを拒否することに必然的に依存します。</p>
</dd>
<dt id="term-Session">Session<a class="headerlink" href="#term-Session" title="Link to this term">¶</a></dt><dd><p>ORMデータベース操作のコンテナまたはスコープです。セッションは、データベースからインスタンスをロードし、マップされたインスタンスへの変更を追跡し、フラッシュ時に単一の作業単位で変更を保持します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session.html"><span class="doc">Using the Session</span></a></p>
</div>
</dd>
<dt id="term-subquery">subquery<a class="headerlink" href="#term-subquery" title="Link to this term">¶</a></dt><dt id="term-scalar-subquery">scalar subquery<a class="headerlink" href="#term-scalar-subquery" title="Link to this term">¶</a></dt><dd><p>囲んでいる <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 文内に埋め込まれた <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 文を参照します。</p>
<p>副問い合わせには2つの一般的な形式があります。1つは厳密に1つのローと1つのカラムを返さなければならない”スカラーselect”と呼ばれる形式で、もう1つは”導出表”として動作し、別のselectのFROM句のソースとして機能します。スカラーselectは、それを囲むselectの <a class="reference internal" href="#term-WHERE-clause"><span class="xref std std-term">WHERE clause</span></a>、 <a class="reference internal" href="#term-columns-clause"><span class="xref std std-term">columns clause</span></a> 、ORDER BY clause、またはHAVING clauseに配置できます。一方、導出表形式は、それを囲む <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> のFROM句に配置できます。</p>
<p>例:</p>
<ol class="arabic">
<li><p>包含する <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> の <a class="reference internal" href="#term-columns-clause"><span class="xref std std-term">columns clause</span></a> に置かれたスカラー副問い合わせ。この例の副問い合わせは <a class="reference internal" href="#term-correlated-subquery"><span class="xref std std-term">correlated subquery</span></a> です。なぜなら、副問い合わせが選択する行の一部は、包含する文によって与えられるからです。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="o">=</span><span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">FROM</span><span class="w"> </span><span class="k">user</span></pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="2">
<li><p>包含する <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> の <a class="reference internal" href="#term-WHERE-clause"><span class="xref std std-term">WHERE clause</span></a> に置かれたスカラー副問い合わせ。この例の副問い合わせは、固定された結果を選択するので、相関はありません。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">status</span><span class="o">=</span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">status_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">status_code</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">code</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span></pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="3">
<li><p>包含する <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> の <a class="reference internal" href="#term-FROM-clause"><span class="xref std std-term">FROM clause</span></a> に置かれた導出表副問い合わせ。このような副問い合わせには、ほとんどの場合エイリアス名が与えられます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">ad_subq</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span>
<span class="w">    </span><span class="k">user</span><span class="w"> </span><span class="k">JOIN</span>
<span class="w">    </span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">email_address</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">address_type</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">ad_subq</span>
<span class="w">    </span><span class="k">ON</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ad_subq</span><span class="p">.</span><span class="n">user_id</span></pre></div>
</div>
</li>
</ol>
</dd>
<dt id="term-transient">transient<a class="headerlink" href="#term-transient" title="Link to this term">¶</a></dt><dd><p>これは、オブジェクトが <a class="reference internal" href="#term-Session"><span class="xref std std-term">Session</span></a> 内で持つことができる主要なオブジェクト状態の1つを記述します。一時オブジェクトとは、データベースIDを持たず、まだセッションに関連付けられていない新しいオブジェクトです。オブジェクトがセッションに追加されると、 <a class="reference internal" href="#term-pending"><span class="xref std std-term">pending</span></a> 状態に移行します。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/session_state_management.html#session-object-states"><span class="std std-ref">Quickie Intro to Object States</span></a></p>
</div>
</dd>
<dt id="term-unique-constraint">unique constraint<a class="headerlink" href="#term-unique-constraint" title="Link to this term">¶</a></dt><dt id="term-unique-key-index">unique key index<a class="headerlink" href="#term-unique-key-index" title="Link to this term">¶</a></dt><dd><p>一意キーインデックスは、データベーステーブル内のデータ値の各行を一意に識別できます。一意キーインデックスは、単一のデータベーステーブル内の単一の列または列のセットで構成されます。NULL値が使用されていない場合、データベーステーブル内の2つの異なる行またはデータレコードが、それらの一意キーインデックス列内で同じデータ値(またはデータ値の組み合わせ)を持つことはできません。データベーステーブルの設計によっては、多くの一意キーインデックスを持つことができますが、主キーインデックスは多くても1つです。(Wikipediaより)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Unique_key#Defining_unique_keys">Unique key (Wkipediaより)</a></p>
</div>
</dd>
<dt id="term-unit-of-work">unit of work<a class="headerlink" href="#term-unit-of-work" title="Link to this term">¶</a></dt><dd><p>オブジェクト・リレーショナル・マッパーなどのパーシスタンス・システムが、一連のオブジェクトに対して行われた変更のリストを保持し、保留中のすべての変更を定期的にデータベースにフラッシュするソフトウェア・アーキテクチャー。</p>
<p>SQLAlchemyの <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> は作業単位パターンを実装しており 、<a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session.add" title="sqlalchemy.orm.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code></a> のようなメソッドを使って <a class="reference internal" href="orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> に追加されたオブジェクトは、作業単位スタイルの永続化に参加します。</p>
<p>SQLAlchemyでの作業持続性の単位がどのように見えるかのウォークスルーについては、 <a class="reference internal" href="tutorial/index.html#unified-tutorial"><span class="std std-ref">SQLAlchemy Unified Tutorial</span></a> の <a class="reference internal" href="tutorial/orm_data_manipulation.html#tutorial-orm-data-manipulation"><span class="std std-ref">Data Manipulation with the ORM</span></a> セクションから始めてください。その後、詳細については、一般的なリファレンスドキュメントの <a class="reference internal" href="orm/session_basics.html#id1"><span class="std std-ref">Basics of Using a Session</span></a> を参照してください。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work (via Martin Fowler)</a></p>
<p><a class="reference internal" href="tutorial/orm_data_manipulation.html#tutorial-orm-data-manipulation"><span class="std std-ref">Data Manipulation with the ORM</span></a></p>
<p><a class="reference internal" href="orm/session_basics.html#id1"><span class="std std-ref">Basics of Using a Session</span></a></p>
</div>
</dd>
<dt id="term-version-id-column">version id column<a class="headerlink" href="#term-version-id-column" title="Link to this term">¶</a></dt><dd><p>SQLAlchemyでは、これは、行が値を変更するときに、特定の行の”バージョン”を追跡する特定のテーブル列の使用を指します。”バージョンID列”をさまざまな方法で使用するさまざまな種類のリレーショナル・パターンがありますが、SQLAlchemyのORMには、行が新しい情報で更新されるときに古いデータをテストする手段として、そのような列を構成できる特別な機能が含まれています。新しいデータを行に入れようとしたときに、この列の最後の既知の”バージョン”が行のバージョンと一致しない場合は、古い情報に基づいて動作していることがわかります。</p>
<p>データベースに”バージョン管理された”行を保存する方法は他にもあり、これはしばしば”一時的な”データと呼ばれます。SQLAlchemyのバージョン管理機能に加えて、さらにいくつかの例がドキュメントに記載されています。以下のリンクを参照してください。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/versioning.html#mapper-version-counter"><span class="std std-ref">Configuring a Version Counter</span></a> - SQLAlchemyの組み込みバージョンID機能です。</p>
<p><a class="reference internal" href="orm/examples.html#examples-versioning"><span class="std std-ref">Versioning Objects</span></a> - 行を一時的にバージョン化するマッピングの他の例です。</p>
</div>
</dd>
<dt id="term-WHERE-clause">WHERE clause<a class="headerlink" href="#term-WHERE-clause" title="Link to this term">¶</a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 文の中で、行をフィルタする条件を示す部分。キーワード <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> の後に続く1つのSQL式です。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">email</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;fred&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;E&#39;</span></pre></div>
</div>
<p>上の例では、 <code class="docutils literal notranslate"><span class="pre">WHERE</span> <span class="pre">user_account.name='fred'AND</span> <span class="pre">user_account.status='E'</span></code> というフレーズが、 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> のWHERE句を構成しています。</p>
</dd>
</dl>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">

    <div id="docs-copyright">
        &copy; <a href="copyright.html">Copyright</a> 2007-2024, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.2.6.

    Documentation last generated: Tue Aug  6 21:40:31 2024 JST

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      document.documentElement.dataset.content_root = './';

    </script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="_static/clipboard.min.js"></script>
        <script type="text/javascript" src="_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="_static/init.js"></script>


    </body>
</html>


